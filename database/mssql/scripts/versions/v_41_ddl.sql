SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

SET NOCOUNT ON
GO

SET XACT_ABORT ON
GO

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
GO

BEGIN TRANSACTION
GO
IF @@ERROR <> 0
   SET NOEXEC ON
GO

 ALTER TABLE [permit].[ORBC_LOA_DETAILS] ADD [PREVIOUS_LOA_ID] [int] NULL
 ALTER TABLE [permit].[ORBC_LOA_DETAILS] ADD  [ORIGINAL_LOA_ID] [int] NULL
 ALTER TABLE [permit].[ORBC_LOA_DETAILS] ALTER COLUMN [START_DATE] [date] NOT NULL
 ALTER TABLE [permit].[ORBC_LOA_DETAILS] ALTER COLUMN [EXPIRY_DATE] [date] NULL
 ALTER TABLE [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS] DROP CONSTRAINT ORBC_LOA_PERMIT_TYPES_PERMIT_TYPE_ID_FK
 EXEC sp_rename @objname = 'permit.ORBC_LOA_PERMIT_TYPE_DETAILS.PERMIT_TYPE_ID', @newname = 'PERMIT_TYPE', @objtype = 'COLUMN'
 ALTER TABLE [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS]
   WITH CHECK ADD CONSTRAINT [FK_ORBC_LOA_PERMIT_TYPES_PERMIT_TYPE] FOREIGN KEY ([PERMIT_TYPE]) REFERENCES [permit].[ORBC_PERMIT_TYPE]([PERMIT_TYPE])
 ALTER TABLE [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS] CHECK CONSTRAINT [FK_ORBC_LOA_PERMIT_TYPES_PERMIT_TYPE]
 ALTER TABLE [permit].[ORBC_LOA_DETAILS] WITH CHECK ADD CONSTRAINT [FK_ORBC_LOA_DETAILS_PREVIOUS_LOA_ID] FOREIGN KEY([PREVIOUS_LOA_ID]) 
 REFERENCES [permit].[ORBC_LOA_DETAILS] ([LOA_ID])
 GO
 ALTER TABLE [permit].[ORBC_LOA_DETAILS] CHECK CONSTRAINT [FK_ORBC_LOA_DETAILS_PREVIOUS_LOA_ID]
 ALTER TABLE [permit].[ORBC_LOA_DETAILS] WITH CHECK ADD CONSTRAINT [FK_ORBC_LOA_DETAILS_ORIGINAL_LOA_ID] FOREIGN KEY([ORIGINAL_LOA_ID]) 
 REFERENCES [permit].[ORBC_LOA_DETAILS] ([LOA_ID])
 GO
 ALTER TABLE [permit].[ORBC_LOA_DETAILS] CHECK CONSTRAINT [FK_ORBC_LOA_DETAILS_ORIGINAL_LOA_ID]
 ALTER TABLE [permit].[ORBC_LOA_VEHICLES] DROP CONSTRAINT [ORBC_LOA_VEHICLES_LOA_ID_FK]
 ALTER TABLE [permit].[ORBC_LOA_VEHICLES]
   WITH CHECK ADD CONSTRAINT [FK_ORBC_LOA_VEHICLES_LOA_ID] FOREIGN KEY ([LOA_ID]) REFERENCES [permit].[ORBC_LOA_DETAILS]([LOA_ID]) 
ALTER TABLE [permit].[ORBC_LOA_VEHICLES] CHECK CONSTRAINT [FK_ORBC_LOA_VEHICLES_LOA_ID]
ALTER TABLE [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS] DROP CONSTRAINT [ORBC_LOA_PERMIT_TYPE_LOA_ID_FK]
ALTER TABLE [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS]
   WITH CHECK ADD CONSTRAINT [FK_ORBC_LOA_PERMIT_TYPE_LOA_ID] FOREIGN KEY ([LOA_ID]) REFERENCES [permit].[ORBC_LOA_DETAILS]([LOA_ID]) 
 ALTER TABLE [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS] CHECK CONSTRAINT [FK_ORBC_LOA_PERMIT_TYPE_LOA_ID]

IF @@ERROR <> 0
   SET NOEXEC ON
GO
EXEC sys.sp_addextendedproperty @name=N'MS_Description', @value=N'previous LoA id' , @level0type=N'SCHEMA',@level0name=N'permit', @level1type=N'TABLE',@level1name=N'ORBC_LOA_DETAILS', @level2type=N'COLUMN',@level2name=N'PREVIOUS_LOA_ID'
EXEC sys.sp_addextendedproperty @name=N'MS_Description', @value=N'Original LoA id' , @level0type=N'SCHEMA',@level0name=N'permit', @level1type=N'TABLE',@level1name=N'ORBC_LOA_DETAILS', @level2type=N'COLUMN',@level2name=N'ORIGINAL_LOA_ID'


CREATE SEQUENCE [permit].[ORBC_LOA_DETAILS_H_ID_SEQ] AS [bigint] START WITH 1 INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 50;

CREATE TABLE [permit].[ORBC_LOA_DETAILS_HIST](
  _LOA_DETAILS_HIST_ID [bigint] DEFAULT (NEXT VALUE FOR [permit].[ORBC_LOA_DETAILS_H_ID_SEQ]) NOT NULL
  ,EFFECTIVE_DATE_HIST [datetime] NOT NULL default getutcdate()
  ,END_DATE_HIST [datetime]
  , [LOA_ID] int NOT NULL, [LOA_NUMBER] int NOT NULL, [COMPANY_ID] int NOT NULL, [START_DATE] date NOT NULL, [EXPIRY_DATE] date NULL, [DOCUMENT_ID] bigint NULL, [COMMENT] nvarchar(4000) NULL, [IS_ACTIVE] char(1) NOT NULL, [APP_CREATE_TIMESTAMP] datetime2 NULL, [APP_CREATE_USERID] nvarchar(30) NULL, [APP_CREATE_USER_GUID] char(32) NULL, [APP_CREATE_USER_DIRECTORY] nvarchar(30) NULL, [APP_LAST_UPDATE_TIMESTAMP] datetime2 NULL, [APP_LAST_UPDATE_USERID] nvarchar(30) NULL, [APP_LAST_UPDATE_USER_GUID] char(32) NULL, [APP_LAST_UPDATE_USER_DIRECTORY] nvarchar(30) NULL, [CONCURRENCY_CONTROL_NUMBER] int NULL, [DB_CREATE_USERID] varchar(63) NOT NULL, [DB_CREATE_TIMESTAMP] datetime2 NOT NULL, [DB_LAST_UPDATE_USERID] varchar(63) NOT NULL, [DB_LAST_UPDATE_TIMESTAMP] datetime2 NOT NULL, [PREVIOUS_LOA_ID] int NULL, [ORIGINAL_LOA_ID] int NULL
  )
ALTER TABLE [permit].[ORBC_LOA_DETAILS_HIST] ADD CONSTRAINT ORBC_15_H_PK PRIMARY KEY CLUSTERED (_LOA_DETAILS_HIST_ID);  
ALTER TABLE [permit].[ORBC_LOA_DETAILS_HIST] ADD CONSTRAINT ORBC_15_H_UK UNIQUE (_LOA_DETAILS_HIST_ID,END_DATE_HIST)
go

CREATE TRIGGER ORBC_LOA_DETAILS_A_S_IUD_TR ON [permit].[ORBC_LOA_DETAILS] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [permit].[ORBC_LOA_DETAILS_HIST] set END_DATE_HIST = @curr_date where LOA_ID in (select LOA_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [permit].[ORBC_LOA_DETAILS_HIST] ([LOA_ID], [LOA_NUMBER], [COMPANY_ID], [START_DATE], [EXPIRY_DATE], [DOCUMENT_ID], [COMMENT], [IS_ACTIVE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [PREVIOUS_LOA_ID], [ORIGINAL_LOA_ID], _LOA_DETAILS_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [LOA_ID], [LOA_NUMBER], [COMPANY_ID], [START_DATE], [EXPIRY_DATE], [DOCUMENT_ID], [COMMENT], [IS_ACTIVE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [PREVIOUS_LOA_ID], [ORIGINAL_LOA_ID], (next value for [permit].[ORBC_LOA_DETAILS_H_ID_SEQ]) as [_LOA_DETAILS_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
go

IF @@ERROR <> 0
   SET NOEXEC ON
GO

CREATE SEQUENCE [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS_H_ID_SEQ] AS [bigint] START WITH 1 INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 50;

CREATE TABLE [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS_HIST](
  _LOA_PERMIT_TYPE_DETAILS_HIST_ID [bigint] DEFAULT (NEXT VALUE FOR [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS_H_ID_SEQ]) NOT NULL
  ,EFFECTIVE_DATE_HIST [datetime] NOT NULL default getutcdate()
  ,END_DATE_HIST [datetime]
  , [LOA_PERMIT_TYPE_ID] int NOT NULL, [LOA_ID] int NOT NULL, [PERMIT_TYPE] varchar(10) NOT NULL, [APP_CREATE_TIMESTAMP] datetime2 NULL, [APP_CREATE_USERID] nvarchar(30) NULL, [APP_CREATE_USER_GUID] char(32) NULL, [APP_CREATE_USER_DIRECTORY] nvarchar(30) NULL, [APP_LAST_UPDATE_TIMESTAMP] datetime2 NULL, [APP_LAST_UPDATE_USERID] nvarchar(30) NULL, [APP_LAST_UPDATE_USER_GUID] char(32) NULL, [APP_LAST_UPDATE_USER_DIRECTORY] nvarchar(30) NULL, [CONCURRENCY_CONTROL_NUMBER] int NULL, [DB_CREATE_USERID] varchar(63) NOT NULL, [DB_CREATE_TIMESTAMP] datetime2 NOT NULL, [DB_LAST_UPDATE_USERID] varchar(63) NOT NULL, [DB_LAST_UPDATE_TIMESTAMP] datetime2 NOT NULL
  )
ALTER TABLE [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS_HIST] ADD CONSTRAINT ORBC_16_H_PK PRIMARY KEY CLUSTERED (_LOA_PERMIT_TYPE_DETAILS_HIST_ID);  
ALTER TABLE [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS_HIST] ADD CONSTRAINT ORBC_16_H_UK UNIQUE (_LOA_PERMIT_TYPE_DETAILS_HIST_ID,END_DATE_HIST)
go

CREATE TRIGGER ORBC_LOA_PD_A_S_IUD_TR ON [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS_HIST] set END_DATE_HIST = @curr_date where LOA_PERMIT_TYPE_ID in (select LOA_PERMIT_TYPE_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS_HIST] ([LOA_PERMIT_TYPE_ID], [LOA_ID], [PERMIT_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _LOA_PERMIT_TYPE_DETAILS_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [LOA_PERMIT_TYPE_ID], [LOA_ID], [PERMIT_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [permit].[ORBC_LOA_PERMIT_TYPE_DETAILS_H_ID_SEQ]) as [_LOA_PERMIT_TYPE_DETAILS_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
go

IF @@ERROR <> 0
   SET NOEXEC ON
GO

CREATE SEQUENCE [permit].[ORBC_LOA_VEHICLES_H_ID_SEQ] AS [bigint] START WITH 1 INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 50;

CREATE TABLE [permit].[ORBC_LOA_VEHICLES_HIST](
  _LOA_VEHICLES_HIST_ID [bigint] DEFAULT (NEXT VALUE FOR [permit].[ORBC_LOA_VEHICLES_H_ID_SEQ]) NOT NULL
  ,EFFECTIVE_DATE_HIST [datetime] NOT NULL default getutcdate()
  ,END_DATE_HIST [datetime]
  , [LOA_VEHICLE_ID] int NOT NULL, [LOA_ID] int NOT NULL, [POWER_UNIT_ID] bigint NULL, [TRAILER_ID] bigint NULL, [APP_CREATE_TIMESTAMP] datetime2 NULL, [APP_CREATE_USERID] nvarchar(30) NULL, [APP_CREATE_USER_GUID] char(32) NULL, [APP_CREATE_USER_DIRECTORY] nvarchar(30) NULL, [APP_LAST_UPDATE_TIMESTAMP] datetime2 NULL, [APP_LAST_UPDATE_USERID] nvarchar(30) NULL, [APP_LAST_UPDATE_USER_GUID] char(32) NULL, [APP_LAST_UPDATE_USER_DIRECTORY] nvarchar(30) NULL, [CONCURRENCY_CONTROL_NUMBER] int NULL, [DB_CREATE_USERID] varchar(63) NOT NULL, [DB_CREATE_TIMESTAMP] datetime2 NOT NULL, [DB_LAST_UPDATE_USERID] varchar(63) NOT NULL, [DB_LAST_UPDATE_TIMESTAMP] datetime2 NOT NULL
  )
ALTER TABLE [permit].[ORBC_LOA_VEHICLES_HIST] ADD CONSTRAINT ORBC_17_H_PK PRIMARY KEY CLUSTERED (_LOA_VEHICLES_HIST_ID);  
ALTER TABLE [permit].[ORBC_LOA_VEHICLES_HIST] ADD CONSTRAINT ORBC_17_H_UK UNIQUE (_LOA_VEHICLES_HIST_ID,END_DATE_HIST)
go

CREATE TRIGGER ORBC_LOA_VEHICLES_A_S_IUD_TR ON [permit].[ORBC_LOA_VEHICLES] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [permit].[ORBC_LOA_VEHICLES_HIST] set END_DATE_HIST = @curr_date where LOA_VEHICLE_ID in (select LOA_VEHICLE_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [permit].[ORBC_LOA_VEHICLES_HIST] ([LOA_VEHICLE_ID], [LOA_ID], [POWER_UNIT_ID], [TRAILER_ID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _LOA_VEHICLES_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [LOA_VEHICLE_ID], [LOA_ID], [POWER_UNIT_ID], [TRAILER_ID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [permit].[ORBC_LOA_VEHICLES_H_ID_SEQ]) as [_LOA_VEHICLES_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
go

IF @@ERROR <> 0
   SET NOEXEC ON
GO

DECLARE @VersionDescription VARCHAR(255)

SET @VersionDescription = 'Add previous loa id and original load id columns to LoA table'

INSERT [dbo].[ORBC_SYS_VERSION] (
   [VERSION_ID],
   [DESCRIPTION],
   [UPDATE_SCRIPT],
   [REVERT_SCRIPT],
   [RELEASE_DATE]
   )
VALUES (
   41,
   @VersionDescription,
   '$(UPDATE_SCRIPT)',
   '$(REVERT_SCRIPT)',
   getutcdate()
   )

IF @@ERROR <> 0
   SET NOEXEC ON
GO

COMMIT TRANSACTION
GO

IF @@ERROR <> 0
   SET NOEXEC ON
GO

DECLARE @Success AS BIT

SET @Success = 1
SET NOEXEC OFF

IF (@Success = 1)
   PRINT 'The database update succeeded'
ELSE
BEGIN
   IF @@TRANCOUNT > 0
      ROLLBACK TRANSACTION

   PRINT 'The database update failed'
END
GO