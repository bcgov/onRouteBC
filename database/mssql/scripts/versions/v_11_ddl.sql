SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET NOCOUNT ON
GO

-- Script generated by Aqua Data Studio Schema Synchronization for MS SQL Server 2016 on Thu Jan 04 10:31:28 GMT-08:00 2024
-- Execute this script on:
-- 		ORBC_DEV_10/<All Schemas> - This database/schema will be modified
-- to synchronize it with MS SQL Server 2016:
-- 		ORBC_DEV_11/<All Schemas>

-- We recommend backing up the database prior to executing the script.

SET XACT_ABORT ON
GO
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
GO
BEGIN TRANSACTION
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.ORBCX_TableDefinitions
PRINT N'Create table dbo.ORBCX_TableDefinitions'
GO
CREATE TABLE [dbo].[ORBCX_TableDefinitions]  ( 
	[SCHEMA_NAME]  	nvarchar(255) NULL,
	[TABLE_NAME]   	nvarchar(255) NULL,
	[TABLE_ALIAS]  	nvarchar(255) NULL,
	[HIST_REQUIRED]	nvarchar(1) NULL,
	[DESCRIPTION]  	nvarchar(max) NULL 
	)
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create function dbo.orbc_ColumnExists
PRINT N'Create function dbo.orbc_ColumnExists'
GO
-- --------------------------------------------------------------------------------------------
-- Create function pims_ColumnExists 
-- --------------------------------------------------------------------------------------------
CREATE FUNCTION [dbo].[orbc_ColumnExists](@TableName varchar(100), @ColumnName varchar(100))
RETURNS nvarchar(1) 
AS
BEGIN
  DECLARE @Result nvarchar(1);
  
  IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.Columns WHERE TABLE_NAME = @TableName AND COLUMN_NAME = @ColumnName)
    SET @Result = 'Y'
  ELSE
    SET @Result = 'N'

  IF @TableName LIKE '%HIST'
    SET @Result = 'N'
 
 RETURN @Result;
END
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create procedure dbo.orbc_error_handling
PRINT N'Create procedure dbo.orbc_error_handling'
GO
-- ............................................................................................


-- --------------------------------------------------------------------------------------------
-- Create procedure orbc_error_handling 
-- --------------------------------------------------------------------------------------------
CREATE PROCEDURE [dbo].[orbc_error_handling] AS 
  begin
    DECLARE @errmsg   nvarchar(2048),
      @severity tinyint,
      @state    tinyint,
      @errno    int,
      @proc     sysname,
      @lineno   int
           
    SELECT @errmsg = error_message(), @severity = error_severity(),
      @state  = error_state(), @errno = error_number(),
      @proc   = error_procedure(), @lineno = error_line()

    IF @errmsg NOT LIKE '***%'
      BEGIN
        SELECT @errmsg = '*** ' + coalesce(quotename(@proc), '<dynamic SQL>') + 
          ', Line ' + ltrim(str(@lineno)) + '. Errno ' + 
          ltrim(str(@errno)) + ': ' + @errmsg
      END

    RAISERROR('%s', @severity, @state, @errmsg)
  end
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence access.ORBC_GROUP_ROLE_H_ID_SEQ
PRINT N'Create sequence access.ORBC_GROUP_ROLE_H_ID_SEQ'
GO
CREATE SEQUENCE [access].[ORBC_GROUP_ROLE_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table access.ORBC_GROUP_ROLE_HIST
PRINT N'Create table access.ORBC_GROUP_ROLE_HIST'
GO
CREATE TABLE [access].[ORBC_GROUP_ROLE_HIST]  ( 
	[_GROUP_ROLE_HIST_ID]           	bigint NOT NULL DEFAULT (NEXT VALUE FOR [access].[ORBC_GROUP_ROLE_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[GROUP_ROLE_ID]                 	int NOT NULL,
	[USER_AUTH_GROUP_TYPE]          	varchar(10) NOT NULL,
	[ROLE_TYPE]                     	varchar(50) NOT NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_GRPROL_H_PK] PRIMARY KEY CLUSTERED([_GROUP_ROLE_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_GRPROL_H_UK
PRINT N'Create unique constraint ORBC_GRPROL_H_UK'
GO
ALTER TABLE [access].[ORBC_GROUP_ROLE_HIST]
	ADD CONSTRAINT [ORBC_GRPROL_H_UK]
	UNIQUE ([_GROUP_ROLE_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence permit.ORBC_PERMIT_STATE_H_ID_SEQ
PRINT N'Create sequence permit.ORBC_PERMIT_STATE_H_ID_SEQ'
GO
CREATE SEQUENCE [permit].[ORBC_PERMIT_STATE_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table permit.ORBC_PERMIT_STATE_HIST
PRINT N'Create table permit.ORBC_PERMIT_STATE_HIST'
GO
CREATE TABLE [permit].[ORBC_PERMIT_STATE_HIST]  ( 
	[_PERMIT_STATE_HIST_ID]         	bigint NOT NULL DEFAULT (NEXT VALUE FOR [permit].[ORBC_PERMIT_STATE_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[ID]                            	bigint NOT NULL,
	[PERMIT_ID]                     	bigint NULL,
	[PERMIT_STATUS_TYPE]            	varchar(20) NULL,
	[STATE_CHANGE_DATE]             	datetime2 NULL,
	[USER_GUID]                     	char(32) NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_PMTST_H_PK] PRIMARY KEY CLUSTERED([_PERMIT_STATE_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_PMTST_H_UK
PRINT N'Create unique constraint ORBC_PMTST_H_UK'
GO
ALTER TABLE [permit].[ORBC_PERMIT_STATE_HIST]
	ADD CONSTRAINT [ORBC_PMTST_H_UK]
	UNIQUE ([_PERMIT_STATE_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dops.ORBC_DOCUMENT_TEMPLATE_H_ID_SEQ
PRINT N'Create sequence dops.ORBC_DOCUMENT_TEMPLATE_H_ID_SEQ'
GO
CREATE SEQUENCE [dops].[ORBC_DOCUMENT_TEMPLATE_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dops.ORBC_DOCUMENT_TEMPLATE_HIST
PRINT N'Create table dops.ORBC_DOCUMENT_TEMPLATE_HIST'
GO
CREATE TABLE [dops].[ORBC_DOCUMENT_TEMPLATE_HIST]  ( 
	[_DOCUMENT_TEMPLATE_HIST_ID]    	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dops].[ORBC_DOCUMENT_TEMPLATE_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[TEMPLATE_ID]                   	int NOT NULL,
	[TEMPLATE_NAME]                 	varchar(50) NOT NULL,
	[TEMPLATE_VERSION]              	int NOT NULL,
	[DOCUMENT_ID]                   	varchar(50) NOT NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_DOCTMP_H_PK] PRIMARY KEY CLUSTERED([_DOCUMENT_TEMPLATE_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_DOCTMP_H_UK
PRINT N'Create unique constraint ORBC_DOCTMP_H_UK'
GO
ALTER TABLE [dops].[ORBC_DOCUMENT_TEMPLATE_HIST]
	ADD CONSTRAINT [ORBC_DOCTMP_H_UK]
	UNIQUE ([_DOCUMENT_TEMPLATE_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence permit.ORBC_RECEIPT_H_ID_SEQ
PRINT N'Create sequence permit.ORBC_RECEIPT_H_ID_SEQ'
GO
CREATE SEQUENCE [permit].[ORBC_RECEIPT_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table permit.ORBC_RECEIPT_HIST
PRINT N'Create table permit.ORBC_RECEIPT_HIST'
GO
CREATE TABLE [permit].[ORBC_RECEIPT_HIST]  ( 
	[_RECEIPT_HIST_ID]              	bigint NOT NULL DEFAULT (NEXT VALUE FOR [permit].[ORBC_RECEIPT_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[RECEIPT_ID]                    	bigint NOT NULL,
	[RECEIPT_NUMBER]                	varchar(19) NOT NULL,
	[TRANSACTION_ID]                	bigint NOT NULL,
	[RECEIPT_DOCUMENT_ID]           	varchar(10) NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NULL,
	CONSTRAINT [ORBC_RCPT_H_PK] PRIMARY KEY CLUSTERED([_RECEIPT_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_RCPT_H_UK
PRINT N'Create unique constraint ORBC_RCPT_H_UK'
GO
ALTER TABLE [permit].[ORBC_RECEIPT_HIST]
	ADD CONSTRAINT [ORBC_RCPT_H_UK]
	UNIQUE ([_RECEIPT_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.ORBC_USER_H_ID_SEQ
PRINT N'Create sequence dbo.ORBC_USER_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[ORBC_USER_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.ORBC_USER_HIST
PRINT N'Create table dbo.ORBC_USER_HIST'
GO
CREATE TABLE [dbo].[ORBC_USER_HIST]  ( 
	[_USER_HIST_ID]                 	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dbo].[ORBC_USER_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[USER_GUID]                     	char(32) NOT NULL,
	[USERNAME]                      	nvarchar(50) NOT NULL,
	[USER_DIRECTORY]                	varchar(10) NOT NULL,
	[CONTACT_ID]                    	int NOT NULL,
	[USER_AUTH_GROUP_TYPE]          	varchar(10) NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_USER_H_PK] PRIMARY KEY CLUSTERED([_USER_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_USER_H_UK
PRINT N'Create unique constraint ORBC_USER_H_UK'
GO
ALTER TABLE [dbo].[ORBC_USER_HIST]
	ADD CONSTRAINT [ORBC_USER_H_UK]
	UNIQUE ([_USER_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dops.ORBC_DOCUMENT_H_ID_SEQ
PRINT N'Create sequence dops.ORBC_DOCUMENT_H_ID_SEQ'
GO
CREATE SEQUENCE [dops].[ORBC_DOCUMENT_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dops.ORBC_DOCUMENT_HIST
PRINT N'Create table dops.ORBC_DOCUMENT_HIST'
GO
CREATE TABLE [dops].[ORBC_DOCUMENT_HIST]  ( 
	[_DOCUMENT_HIST_ID]             	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dops].[ORBC_DOCUMENT_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[ID]                            	bigint NOT NULL,
	[S3_OBJECT_ID]                  	uniqueidentifier NOT NULL,
	[S3_VERSION_ID]                 	bigint NULL,
	[S3_LOCATION]                   	varchar(200) NOT NULL,
	[OBJECT_MIME_TYPE]              	varchar(200) NOT NULL,
	[FILE_NAME]                     	varchar(50) NOT NULL,
	[DMS_VERSION_ID]                	int NOT NULL,
	[COMPANY_ID]                    	int NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_DOCMNT_H_PK] PRIMARY KEY CLUSTERED([_DOCUMENT_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_DOCMNT_H_UK
PRINT N'Create unique constraint ORBC_DOCMNT_H_UK'
GO
ALTER TABLE [dops].[ORBC_DOCUMENT_HIST]
	ADD CONSTRAINT [ORBC_DOCMNT_H_UK]
	UNIQUE ([_DOCUMENT_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.ORBC_COMPANY_H_ID_SEQ
PRINT N'Create sequence dbo.ORBC_COMPANY_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[ORBC_COMPANY_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.ORBC_COMPANY_HIST
PRINT N'Create table dbo.ORBC_COMPANY_HIST'
GO
CREATE TABLE [dbo].[ORBC_COMPANY_HIST]  ( 
	[_COMPANY_HIST_ID]              	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dbo].[ORBC_COMPANY_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[COMPANY_ID]                    	int NOT NULL,
	[COMPANY_GUID]                  	char(32) NULL,
	[CLIENT_NUMBER]                 	char(13) NULL,
	[TPS_CLIENT_HASH]               	varchar(64) NULL,
	[LEGAL_NAME]                    	nvarchar(500) NOT NULL,
	[ALTERNATE_NAME]                	nvarchar(150) NULL,
	[COMPANY_DIRECTORY]             	varchar(10) NOT NULL,
	[MAILING_ADDRESS_ID]            	int NOT NULL,
	[PHONE]                         	varchar(20) NULL,
	[EXTENSION]                     	varchar(5) NULL,
	[FAX]                           	varchar(20) NULL,
	[EMAIL]                         	varchar(50) NULL,
	[PRIMARY_CONTACT_ID]            	int NULL,
	[ACCOUNT_REGION]                	char(1) NULL,
	[ACCOUNT_SOURCE]                	char(1) NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_COMPNY_H_PK] PRIMARY KEY CLUSTERED([_COMPANY_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_COMPNY_H_UK
PRINT N'Create unique constraint ORBC_COMPNY_H_UK'
GO
ALTER TABLE [dbo].[ORBC_COMPANY_HIST]
	ADD CONSTRAINT [ORBC_COMPNY_H_UK]
	UNIQUE ([_COMPANY_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence permit.ORBC_PERMIT_TRANSACTION_H_ID_SEQ
PRINT N'Create sequence permit.ORBC_PERMIT_TRANSACTION_H_ID_SEQ'
GO
CREATE SEQUENCE [permit].[ORBC_PERMIT_TRANSACTION_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table permit.ORBC_PERMIT_TRANSACTION_HIST
PRINT N'Create table permit.ORBC_PERMIT_TRANSACTION_HIST'
GO
CREATE TABLE [permit].[ORBC_PERMIT_TRANSACTION_HIST]  ( 
	[_PERMIT_TRANSACTION_HIST_ID]   	bigint NOT NULL DEFAULT (NEXT VALUE FOR [permit].[ORBC_PERMIT_TRANSACTION_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[ID]                            	bigint NOT NULL,
	[PERMIT_ID]                     	bigint NOT NULL,
	[TRANSACTION_ID]                	bigint NOT NULL,
	[TRANSACTION_AMOUNT]            	decimal(18,0) NOT NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NULL,
	CONSTRAINT [ORBC_PMTTXN_H_PK] PRIMARY KEY CLUSTERED([_PERMIT_TRANSACTION_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_PMTTXN_H_UK
PRINT N'Create unique constraint ORBC_PMTTXN_H_UK'
GO
ALTER TABLE [permit].[ORBC_PERMIT_TRANSACTION_HIST]
	ADD CONSTRAINT [ORBC_PMTTXN_H_UK]
	UNIQUE ([_PERMIT_TRANSACTION_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.ORBC_TRAILER_H_ID_SEQ
PRINT N'Create sequence dbo.ORBC_TRAILER_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[ORBC_TRAILER_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.ORBC_TRAILER_HIST
PRINT N'Create table dbo.ORBC_TRAILER_HIST'
GO
CREATE TABLE [dbo].[ORBC_TRAILER_HIST]  ( 
	[_TRAILER_HIST_ID]              	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dbo].[ORBC_TRAILER_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[TRAILER_ID]                    	bigint NOT NULL,
	[UNIT_NUMBER]                   	nvarchar(10) NULL,
	[PLATE]                         	nvarchar(10) NOT NULL,
	[PROVINCE_TYPE]                 	char(5) NOT NULL,
	[YEAR]                          	smallint NOT NULL,
	[MAKE]                          	nvarchar(50) NOT NULL,
	[VIN]                           	char(6) NOT NULL,
	[TRAILER_TYPE]                  	char(7) NOT NULL,
	[EMPTY_TRAILER_WIDTH]           	numeric(18,0) NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	[COMPANY_ID]                    	int NULL,
	CONSTRAINT [ORBC_TRLR_H_PK] PRIMARY KEY CLUSTERED([_TRAILER_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_TRLR_H_UK
PRINT N'Create unique constraint ORBC_TRLR_H_UK'
GO
ALTER TABLE [dbo].[ORBC_TRAILER_HIST]
	ADD CONSTRAINT [ORBC_TRLR_H_UK]
	UNIQUE ([_TRAILER_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.ORBC_IDIR_USER_H_ID_SEQ
PRINT N'Create sequence dbo.ORBC_IDIR_USER_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[ORBC_IDIR_USER_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.ORBC_IDIR_USER_HIST
PRINT N'Create table dbo.ORBC_IDIR_USER_HIST'
GO
CREATE TABLE [dbo].[ORBC_IDIR_USER_HIST]  ( 
	[_IDIR_USER_HIST_ID]            	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dbo].[ORBC_IDIR_USER_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[USER_GUID]                     	char(32) NOT NULL,
	[USERNAME]                      	nvarchar(50) NOT NULL,
	[FIRST_NAME]                    	nvarchar(100) NULL,
	[LAST_NAME]                     	nvarchar(100) NULL,
	[EMAIL]                         	nvarchar(100) NOT NULL,
	[USER_STATUS_TYPE]              	varchar(10) NOT NULL,
	[USER_AUTH_GROUP_TYPE]          	varchar(10) NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_IDRUSR_H_PK] PRIMARY KEY CLUSTERED([_IDIR_USER_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_IDRUSR_H_UK
PRINT N'Create unique constraint ORBC_IDRUSR_H_UK'
GO
ALTER TABLE [dbo].[ORBC_IDIR_USER_HIST]
	ADD CONSTRAINT [ORBC_IDRUSR_H_UK]
	UNIQUE ([_IDIR_USER_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.ORBC_POWER_UNIT_H_ID_SEQ
PRINT N'Create sequence dbo.ORBC_POWER_UNIT_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[ORBC_POWER_UNIT_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.ORBC_POWER_UNIT_HIST
PRINT N'Create table dbo.ORBC_POWER_UNIT_HIST'
GO
CREATE TABLE [dbo].[ORBC_POWER_UNIT_HIST]  ( 
	[_POWER_UNIT_HIST_ID]           	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dbo].[ORBC_POWER_UNIT_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[POWER_UNIT_ID]                 	bigint NOT NULL,
	[UNIT_NUMBER]                   	nvarchar(10) NULL,
	[PLATE]                         	nvarchar(10) NOT NULL,
	[PROVINCE_TYPE]                 	char(5) NOT NULL,
	[YEAR]                          	smallint NOT NULL,
	[MAKE]                          	nvarchar(50) NOT NULL,
	[VIN]                           	char(6) NOT NULL,
	[LICENSED_GVW]                  	numeric(18,0) NULL,
	[POWER_UNIT_TYPE]               	char(7) NOT NULL,
	[STEER_AXLE_TIRE_SIZE]          	int NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	[COMPANY_ID]                    	int NULL,
	CONSTRAINT [ORBC_PWRUNI_H_PK] PRIMARY KEY CLUSTERED([_POWER_UNIT_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_PWRUNI_H_UK
PRINT N'Create unique constraint ORBC_PWRUNI_H_UK'
GO
ALTER TABLE [dbo].[ORBC_POWER_UNIT_HIST]
	ADD CONSTRAINT [ORBC_PWRUNI_H_UK]
	UNIQUE ([_POWER_UNIT_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dops.ORBC_EXTERNAL_DOCUMENT_H_ID_SEQ
PRINT N'Create sequence dops.ORBC_EXTERNAL_DOCUMENT_H_ID_SEQ'
GO
CREATE SEQUENCE [dops].[ORBC_EXTERNAL_DOCUMENT_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dops.ORBC_EXTERNAL_DOCUMENT_HIST
PRINT N'Create table dops.ORBC_EXTERNAL_DOCUMENT_HIST'
GO
CREATE TABLE [dops].[ORBC_EXTERNAL_DOCUMENT_HIST]  ( 
	[_EXTERNAL_DOCUMENT_HIST_ID]    	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dops].[ORBC_EXTERNAL_DOCUMENT_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[ID]                            	bigint NOT NULL,
	[DOCUMENT_NAME]                 	varchar(50) NOT NULL,
	[DOCUMENT_DESCRIPTION]          	varchar(200) NULL,
	[DOCUMENT_LOCATION]             	varchar(200) NOT NULL,
	[DOCUMENT_MIME_TYPE]            	varchar(200) NOT NULL,
	[DOCUMENT_VERSION_ID]           	int NOT NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_EXTDOC_H_PK] PRIMARY KEY CLUSTERED([_EXTERNAL_DOCUMENT_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_EXTDOC_H_UK
PRINT N'Create unique constraint ORBC_EXTDOC_H_UK'
GO
ALTER TABLE [dops].[ORBC_EXTERNAL_DOCUMENT_HIST]
	ADD CONSTRAINT [ORBC_EXTDOC_H_UK]
	UNIQUE ([_EXTERNAL_DOCUMENT_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.ORBC_COMPANY_USER_H_ID_SEQ
PRINT N'Create sequence dbo.ORBC_COMPANY_USER_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[ORBC_COMPANY_USER_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.ORBC_COMPANY_USER_HIST
PRINT N'Create table dbo.ORBC_COMPANY_USER_HIST'
GO
CREATE TABLE [dbo].[ORBC_COMPANY_USER_HIST]  ( 
	[_COMPANY_USER_HIST_ID]         	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dbo].[ORBC_COMPANY_USER_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[COMPANY_USER_ID]               	int NOT NULL,
	[COMPANY_ID]                    	int NOT NULL,
	[USER_GUID]                     	char(32) NOT NULL,
	[USER_AUTH_GROUP_TYPE]          	varchar(10) NOT NULL,
  [USER_STATUS_TYPE] [varchar](10) NOT NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_CMPUSR_H_PK] PRIMARY KEY CLUSTERED([_COMPANY_USER_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_CMPUSR_H_UK
PRINT N'Create unique constraint ORBC_CMPUSR_H_UK'
GO
ALTER TABLE [dbo].[ORBC_COMPANY_USER_HIST]
	ADD CONSTRAINT [ORBC_CMPUSR_H_UK]
	UNIQUE ([_COMPANY_USER_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence permit.ORBC_PERMIT_COMMENTS_H_ID_SEQ
PRINT N'Create sequence permit.ORBC_PERMIT_COMMENTS_H_ID_SEQ'
GO
CREATE SEQUENCE [permit].[ORBC_PERMIT_COMMENTS_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table permit.ORBC_PERMIT_COMMENTS_HIST
PRINT N'Create table permit.ORBC_PERMIT_COMMENTS_HIST'
GO
CREATE TABLE [permit].[ORBC_PERMIT_COMMENTS_HIST]  ( 
	[_PERMIT_COMMENTS_HIST_ID]      	bigint NOT NULL DEFAULT (NEXT VALUE FOR [permit].[ORBC_PERMIT_COMMENTS_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[ID]                            	bigint NOT NULL,
	[PERMIT_ID]                     	bigint NOT NULL,
	[COMMENT]                       	nvarchar(500) NULL,
	[INTERNAL_ONLY]                 	bit NOT NULL,
	[USER_GUID]                     	char(32) NULL,
	[COMMENT_DATE]                  	datetime2 NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_PMTCMT_H_PK] PRIMARY KEY CLUSTERED([_PERMIT_COMMENTS_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_PMTCMT_H_UK
PRINT N'Create unique constraint ORBC_PMTCMT_H_UK'
GO
ALTER TABLE [permit].[ORBC_PERMIT_COMMENTS_HIST]
	ADD CONSTRAINT [ORBC_PMTCMT_H_UK]
	UNIQUE ([_PERMIT_COMMENTS_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.ORBC_PENDING_IDIR_USER_H_ID_SEQ
PRINT N'Create sequence dbo.ORBC_PENDING_IDIR_USER_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[ORBC_PENDING_IDIR_USER_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.ORBC_PENDING_IDIR_USER_HIST
PRINT N'Create table dbo.ORBC_PENDING_IDIR_USER_HIST'
GO
CREATE TABLE [dbo].[ORBC_PENDING_IDIR_USER_HIST]  ( 
	[_PENDING_IDIR_USER_HIST_ID]    	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dbo].[ORBC_PENDING_IDIR_USER_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[USERNAME]                      	varchar(50) NOT NULL,
	[USER_AUTH_GROUP_TYPE]          	varchar(10) NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_PIDRUS_H_PK] PRIMARY KEY CLUSTERED([_PENDING_IDIR_USER_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_PIDRUS_H_UK
PRINT N'Create unique constraint ORBC_PIDRUS_H_UK'
GO
ALTER TABLE [dbo].[ORBC_PENDING_IDIR_USER_HIST]
	ADD CONSTRAINT [ORBC_PIDRUS_H_UK]
	UNIQUE ([_PENDING_IDIR_USER_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence permit.ORBC_TRANSACTION_H_ID_SEQ
PRINT N'Create sequence permit.ORBC_TRANSACTION_H_ID_SEQ'
GO
CREATE SEQUENCE [permit].[ORBC_TRANSACTION_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table permit.ORBC_TRANSACTION_HIST
PRINT N'Create table permit.ORBC_TRANSACTION_HIST'
GO
CREATE TABLE [permit].[ORBC_TRANSACTION_HIST]  ( 
	[_TRANSACTION_HIST_ID]          	bigint NOT NULL DEFAULT (NEXT VALUE FOR [permit].[ORBC_TRANSACTION_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[TRANSACTION_ID]                	bigint NOT NULL,
	[TRANSACTION_TYPE]              	varchar(3) NOT NULL,
	[PAYMENT_METHOD_TYPE]           	varchar(15) NOT NULL,
	[PAYMENT_CARD_TYPE]             	varchar(5) NULL,
	[TOTAL_TRANSACTION_AMOUNT]      	decimal(18,0) NOT NULL,
	[TRANSACTION_SUBMIT_DATE]       	datetime2 NOT NULL,
	[TRANSACTION_ORDER_NUMBER]      	varchar(30) NOT NULL,
	[PG_TRANSACTION_ID]             	bigint NULL,
	[PG_TRANSACTION_APPROVED]       	tinyint NULL,
	[PG_AUTH_CODE]                  	varchar(32) NULL,
	[PG_TRANSACTION_CARD_TYPE]      	nvarchar(2) NULL,
	[PG_TRANSACTION_DATE]           	datetime2 NULL,
	[PG_CVD_ID]                     	tinyint NULL,
	[PG_PAYMENT_METHOD]             	varchar(2) NULL,
	[PG_MESSAGE_ID]                 	int NULL,
	[PG_MESSAGE_TEXT]               	varchar(100) NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NULL,
	CONSTRAINT [ORBC_TXN_H_PK] PRIMARY KEY CLUSTERED([_TRANSACTION_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_TXN_H_UK
PRINT N'Create unique constraint ORBC_TXN_H_UK'
GO
ALTER TABLE [permit].[ORBC_TRANSACTION_HIST]
	ADD CONSTRAINT [ORBC_TXN_H_UK]
	UNIQUE ([_TRANSACTION_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.ORBC_CONTACT_H_ID_SEQ
PRINT N'Create sequence dbo.ORBC_CONTACT_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[ORBC_CONTACT_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.ORBC_CONTACT_HIST
PRINT N'Create table dbo.ORBC_CONTACT_HIST'
GO
CREATE TABLE [dbo].[ORBC_CONTACT_HIST]  ( 
	[_CONTACT_HIST_ID]              	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dbo].[ORBC_CONTACT_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[CONTACT_ID]                    	int NOT NULL,
	[FIRST_NAME]                    	nvarchar(100) NOT NULL,
	[LAST_NAME]                     	nvarchar(100) NOT NULL,
	[EMAIL]                         	nvarchar(100) NOT NULL,
	[PHONE_1]                       	varchar(20) NOT NULL,
	[EXTENSION_1]                   	varchar(5) NULL,
	[PHONE_2]                       	varchar(20) NULL,
	[EXTENSION_2]                   	varchar(5) NULL,
	[FAX]                           	varchar(20) NULL,
	[CITY]                          	nvarchar(100) NOT NULL,
	[PROVINCE_TYPE]                 	char(5) NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_CONTCT_H_PK] PRIMARY KEY CLUSTERED([_CONTACT_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_CONTCT_H_UK
PRINT N'Create unique constraint ORBC_CONTCT_H_UK'
GO
ALTER TABLE [dbo].[ORBC_CONTACT_HIST]
	ADD CONSTRAINT [ORBC_CONTCT_H_UK]
	UNIQUE ([_CONTACT_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence permit.ORBC_PERMIT_H_ID_SEQ
PRINT N'Create sequence permit.ORBC_PERMIT_H_ID_SEQ'
GO
CREATE SEQUENCE [permit].[ORBC_PERMIT_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table permit.ORBC_PERMIT_HIST
PRINT N'Create table permit.ORBC_PERMIT_HIST'
GO
CREATE TABLE [permit].[ORBC_PERMIT_HIST]  ( 
	[_PERMIT_HIST_ID]               	bigint NOT NULL DEFAULT (NEXT VALUE FOR [permit].[ORBC_PERMIT_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[ID]                            	bigint NOT NULL,
	[ORIGINAL_ID]                   	bigint NULL,
	[COMPANY_ID]                    	int NULL,
	[PERMIT_TYPE]                   	varchar(10) NULL,
	[PERMIT_APPROVAL_SOURCE_TYPE]   	varchar(8) NULL,
	[PERMIT_ISSUED_BY_TYPE]         	varchar(15) NULL,
	[ISSUER_USER_GUID]              	char(32) NULL,
	[PERMIT_APPLICATION_ORIGIN_TYPE]	varchar(8) NULL,
	[APPLICATION_NUMBER]            	varchar(19) NULL,
	[PERMIT_NUMBER]                 	varchar(19) NULL,
	[TPS_PERMIT_NUMBER]             	nvarchar(11) NULL,
	[REVISION]                      	tinyint NULL,
	[PREVIOUS_REV_ID]               	bigint NULL,
	[OWNER_USER_GUID]               	char(32) NULL,
	[PERMIT_STATUS_TYPE]            	varchar(20) NULL,
	[PERMIT_ISSUE_DATE_TIME]        	datetime2 NULL,
	[DOCUMENT_ID]                   	varchar(10) NULL,
	[COMMENT]                       	nvarchar(3000) NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_PERMIT_H_PK] PRIMARY KEY CLUSTERED([_PERMIT_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_PERMIT_H_UK
PRINT N'Create unique constraint ORBC_PERMIT_H_UK'
GO
ALTER TABLE [permit].[ORBC_PERMIT_HIST]
	ADD CONSTRAINT [ORBC_PERMIT_H_UK]
	UNIQUE ([_PERMIT_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.ORBC_PENDING_USER_H_ID_SEQ
PRINT N'Create sequence dbo.ORBC_PENDING_USER_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[ORBC_PENDING_USER_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.ORBC_PENDING_USER_HIST
PRINT N'Create table dbo.ORBC_PENDING_USER_HIST'
GO
CREATE TABLE [dbo].[ORBC_PENDING_USER_HIST]  ( 
	[_PENDING_USER_HIST_ID]         	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dbo].[ORBC_PENDING_USER_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[PENDING_USER_ID]               	int NOT NULL,
	[COMPANY_ID]                    	int NOT NULL,
	[USERNAME]                      	varchar(50) NOT NULL,
	[USER_GUID]                     	char(32) NULL,
	[USER_AUTH_GROUP_TYPE]          	varchar(10) NULL,
	[FIRST_NAME]                    	nvarchar(50) NULL,
	[LAST_NAME]                     	nvarchar(50) NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_PNDUSR_H_PK] PRIMARY KEY CLUSTERED([_PENDING_USER_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_PNDUSR_H_UK
PRINT N'Create unique constraint ORBC_PNDUSR_H_UK'
GO
ALTER TABLE [dbo].[ORBC_PENDING_USER_HIST]
	ADD CONSTRAINT [ORBC_PNDUSR_H_UK]
	UNIQUE ([_PENDING_USER_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence dbo.ORBC_ADDRESS_H_ID_SEQ
PRINT N'Create sequence dbo.ORBC_ADDRESS_H_ID_SEQ'
GO
CREATE SEQUENCE [dbo].[ORBC_ADDRESS_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table dbo.ORBC_ADDRESS_HIST
PRINT N'Create table dbo.ORBC_ADDRESS_HIST'
GO
CREATE TABLE [dbo].[ORBC_ADDRESS_HIST]  ( 
	[_ADDRESS_HIST_ID]              	bigint NOT NULL DEFAULT (NEXT VALUE FOR [dbo].[ORBC_ADDRESS_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[ADDRESS_ID]                    	int NOT NULL,
	[ADDRESS_LINE_1]                	nvarchar(150) NOT NULL,
	[ADDRESS_LINE_2]                	nvarchar(100) NULL,
	[CITY]                          	nvarchar(100) NOT NULL,
	[PROVINCE_TYPE]                 	char(5) NOT NULL,
	[POSTAL_CODE]                   	varchar(7) NOT NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_ADDR_H_PK] PRIMARY KEY CLUSTERED([_ADDRESS_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_ADDR_H_UK
PRINT N'Create unique constraint ORBC_ADDR_H_UK'
GO
ALTER TABLE [dbo].[ORBC_ADDRESS_HIST]
	ADD CONSTRAINT [ORBC_ADDR_H_UK]
	UNIQUE ([_ADDRESS_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create sequence permit.ORBC_PERMIT_DATA_H_ID_SEQ
PRINT N'Create sequence permit.ORBC_PERMIT_DATA_H_ID_SEQ'
GO
CREATE SEQUENCE [permit].[ORBC_PERMIT_DATA_H_ID_SEQ]
	AS bigint
	START WITH 1
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	NO CYCLE
	CACHE 50
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create table permit.ORBC_PERMIT_DATA_HIST
PRINT N'Create table permit.ORBC_PERMIT_DATA_HIST'
GO
CREATE TABLE [permit].[ORBC_PERMIT_DATA_HIST]  ( 
	[_PERMIT_DATA_HIST_ID]          	bigint NOT NULL DEFAULT (NEXT VALUE FOR [permit].[ORBC_PERMIT_DATA_H_ID_SEQ]),
	[EFFECTIVE_DATE_HIST]           	datetime NOT NULL DEFAULT (getutcdate()),
	[END_DATE_HIST]                 	datetime NULL,
	[ID]                            	bigint NOT NULL,
	[PERMIT_ID]                     	bigint NULL,
	[PERMIT_DATA]                   	nvarchar(4000) NULL,
	[APP_CREATE_TIMESTAMP]          	datetime2 NULL,
	[APP_CREATE_USERID]             	nvarchar(30) NULL,
	[APP_CREATE_USER_GUID]          	char(32) NULL,
	[APP_CREATE_USER_DIRECTORY]     	nvarchar(30) NULL,
	[APP_LAST_UPDATE_TIMESTAMP]     	datetime2 NULL,
	[APP_LAST_UPDATE_USERID]        	nvarchar(30) NULL,
	[APP_LAST_UPDATE_USER_GUID]     	char(32) NULL,
	[APP_LAST_UPDATE_USER_DIRECTORY]	nvarchar(30) NULL,
	[CONCURRENCY_CONTROL_NUMBER]    	int NULL,
	[DB_CREATE_USERID]              	varchar(63) NOT NULL,
	[DB_CREATE_TIMESTAMP]           	datetime2 NOT NULL,
	[DB_LAST_UPDATE_USERID]         	varchar(63) NOT NULL,
	[DB_LAST_UPDATE_TIMESTAMP]      	datetime2 NOT NULL,
	CONSTRAINT [ORBC_PMTDAT_H_PK] PRIMARY KEY CLUSTERED([_PERMIT_DATA_HIST_ID])
 ON [PRIMARY])
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create unique constraint ORBC_PMTDAT_H_UK
PRINT N'Create unique constraint ORBC_PMTDAT_H_UK'
GO
ALTER TABLE [permit].[ORBC_PERMIT_DATA_HIST]
	ADD CONSTRAINT [ORBC_PMTDAT_H_UK]
	UNIQUE ([_PERMIT_DATA_HIST_ID], [END_DATE_HIST]) 
	WITH (
		DATA_COMPRESSION = NONE
	) ON [PRIMARY]
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dops.ORBC_DOCMNT_I_S_U_TR
PRINT N'Create trigger dops.ORBC_DOCMNT_I_S_U_TR'
GO
CREATE TRIGGER [dops].[ORBC_DOCMNT_I_S_U_TR] ON dops.[ORBC_DOCUMENT] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.ID = deleted.ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dops].[ORBC_DOCUMENT]
    set "S3_OBJECT_ID" = inserted."S3_OBJECT_ID",
      "S3_VERSION_ID" = inserted."S3_VERSION_ID",
      "S3_LOCATION" = inserted."S3_LOCATION",
      "OBJECT_MIME_TYPE" = inserted."OBJECT_MIME_TYPE",
      "FILE_NAME" = inserted."FILE_NAME",
      "DMS_VERSION_ID" = inserted."DMS_VERSION_ID",
      "COMPANY_ID" = inserted."COMPANY_ID",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dops].[ORBC_DOCUMENT]
    inner join inserted
    on (ORBC_DOCUMENT.ID = inserted.ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dops].[ORBC_DOCMNT_I_S_U_TR] ON dops.[ORBC_DOCUMENT]
GO

-- Create trigger dbo.ORBC_PWRUNT_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_PWRUNT_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_PWRUNT_I_S_U_TR] ON dbo.[ORBC_POWER_UNIT_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.POWER_UNIT_TYPE = deleted.POWER_UNIT_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_POWER_UNIT_TYPE]
    set "POWER_UNIT_TYPE" = inserted."POWER_UNIT_TYPE",
      "TYPE" = inserted."TYPE",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "SORT_ORDER" = inserted."SORT_ORDER",
      "IS_ACTIVE" = inserted."IS_ACTIVE",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_POWER_UNIT_TYPE]
    inner join inserted
    on (ORBC_POWER_UNIT_TYPE.POWER_UNIT_TYPE = inserted.POWER_UNIT_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_PWRUNT_I_S_U_TR] ON dbo.[ORBC_POWER_UNIT_TYPE]
GO

-- Create trigger dbo.ORBC_PNDUSR_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_PNDUSR_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_PNDUSR_I_S_U_TR] ON dbo.[ORBC_PENDING_USER] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.PENDING_USER_ID = deleted.PENDING_USER_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_PENDING_USER]
    set "COMPANY_ID" = inserted."COMPANY_ID",
      "USERNAME" = inserted."USERNAME",
      "USER_GUID" = inserted."USER_GUID",
      "USER_AUTH_GROUP_TYPE" = inserted."USER_AUTH_GROUP_TYPE",
      "FIRST_NAME" = inserted."FIRST_NAME",
      "LAST_NAME" = inserted."LAST_NAME",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_PENDING_USER]
    inner join inserted
    on (ORBC_PENDING_USER.PENDING_USER_ID = inserted.PENDING_USER_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_PNDUSR_I_S_U_TR] ON dbo.[ORBC_PENDING_USER]
GO

-- Create trigger permit.ORBC_TXN_I_S_U_TR
PRINT N'Create trigger permit.ORBC_TXN_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_TXN_I_S_U_TR] ON permit.[ORBC_TRANSACTION] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.TRANSACTION_ID = deleted.TRANSACTION_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_TRANSACTION]
    set "TRANSACTION_TYPE" = inserted."TRANSACTION_TYPE",
      "PAYMENT_METHOD_TYPE" = inserted."PAYMENT_METHOD_TYPE",
      "PAYMENT_CARD_TYPE" = inserted."PAYMENT_CARD_TYPE",
      "TOTAL_TRANSACTION_AMOUNT" = inserted."TOTAL_TRANSACTION_AMOUNT",
      "TRANSACTION_SUBMIT_DATE" = inserted."TRANSACTION_SUBMIT_DATE",
      "TRANSACTION_ORDER_NUMBER" = inserted."TRANSACTION_ORDER_NUMBER",
      "PG_TRANSACTION_ID" = inserted."PG_TRANSACTION_ID",
      "PG_TRANSACTION_APPROVED" = inserted."PG_TRANSACTION_APPROVED",
      "PG_AUTH_CODE" = inserted."PG_AUTH_CODE",
      "PG_TRANSACTION_CARD_TYPE" = inserted."PG_TRANSACTION_CARD_TYPE",
      "PG_TRANSACTION_DATE" = inserted."PG_TRANSACTION_DATE",
      "PG_CVD_ID" = inserted."PG_CVD_ID",
      "PG_PAYMENT_METHOD" = inserted."PG_PAYMENT_METHOD",
      "PG_MESSAGE_ID" = inserted."PG_MESSAGE_ID",
      "PG_MESSAGE_TEXT" = inserted."PG_MESSAGE_TEXT",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_TRANSACTION]
    inner join inserted
    on (ORBC_TRANSACTION.TRANSACTION_ID = inserted.TRANSACTION_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_TXN_I_S_U_TR] ON permit.[ORBC_TRANSACTION]
GO

-- Create trigger permit.ORBC_PMTSTT_I_S_U_TR
PRINT N'Create trigger permit.ORBC_PMTSTT_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_PMTSTT_I_S_U_TR] ON permit.[ORBC_PERMIT_STATUS_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.PERMIT_STATUS_TYPE = deleted.PERMIT_STATUS_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_PERMIT_STATUS_TYPE]
    set "PERMIT_STATUS_TYPE" = inserted."PERMIT_STATUS_TYPE",
      "NAME" = inserted."NAME",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_PERMIT_STATUS_TYPE]
    inner join inserted
    on (ORBC_PERMIT_STATUS_TYPE.PERMIT_STATUS_TYPE = inserted.PERMIT_STATUS_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_PMTSTT_I_S_U_TR] ON permit.[ORBC_PERMIT_STATUS_TYPE]
GO

-- Create trigger access.ORBC_GRPROL_A_S_IUD_TR
PRINT N'Create trigger access.ORBC_GRPROL_A_S_IUD_TR'
GO
CREATE TRIGGER [access].[ORBC_GRPROL_A_S_IUD_TR] ON access.[ORBC_GROUP_ROLE] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [access].[ORBC_GROUP_ROLE_HIST] set END_DATE_HIST = @curr_date where GROUP_ROLE_ID in (select GROUP_ROLE_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [access].[ORBC_GROUP_ROLE_HIST] ([GROUP_ROLE_ID], [USER_AUTH_GROUP_TYPE], [ROLE_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _GROUP_ROLE_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [GROUP_ROLE_ID], [USER_AUTH_GROUP_TYPE], [ROLE_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [access].[ORBC_GROUP_ROLE_H_ID_SEQ]) as [_GROUP_ROLE_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger permit.ORBC_PMTST_A_S_IUD_TR
PRINT N'Create trigger permit.ORBC_PMTST_A_S_IUD_TR'
GO
CREATE TRIGGER [permit].[ORBC_PMTST_A_S_IUD_TR] ON permit.[ORBC_PERMIT_STATE] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [permit].[ORBC_PERMIT_STATE_HIST] set END_DATE_HIST = @curr_date where ID in (select ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [permit].[ORBC_PERMIT_STATE_HIST] ([ID], [PERMIT_ID], [PERMIT_STATUS_TYPE], [STATE_CHANGE_DATE], [USER_GUID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _PERMIT_STATE_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [ID], [PERMIT_ID], [PERMIT_STATUS_TYPE], [STATE_CHANGE_DATE], [USER_GUID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [permit].[ORBC_PERMIT_STATE_H_ID_SEQ]) as [_PERMIT_STATE_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dops.ORBC_DOCTMP_A_S_IUD_TR
PRINT N'Create trigger dops.ORBC_DOCTMP_A_S_IUD_TR'
GO
CREATE TRIGGER [dops].[ORBC_DOCTMP_A_S_IUD_TR] ON dops.[ORBC_DOCUMENT_TEMPLATE] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dops].[ORBC_DOCUMENT_TEMPLATE_HIST] set END_DATE_HIST = @curr_date where TEMPLATE_ID in (select TEMPLATE_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dops].[ORBC_DOCUMENT_TEMPLATE_HIST] ([TEMPLATE_ID], [TEMPLATE_NAME], [TEMPLATE_VERSION], [DOCUMENT_ID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _DOCUMENT_TEMPLATE_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [TEMPLATE_ID], [TEMPLATE_NAME], [TEMPLATE_VERSION], [DOCUMENT_ID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dops].[ORBC_DOCUMENT_TEMPLATE_H_ID_SEQ]) as [_DOCUMENT_TEMPLATE_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger permit.ORBC_RCPT_A_S_IUD_TR
PRINT N'Create trigger permit.ORBC_RCPT_A_S_IUD_TR'
GO
CREATE TRIGGER [permit].[ORBC_RCPT_A_S_IUD_TR] ON permit.[ORBC_RECEIPT] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [permit].[ORBC_RECEIPT_HIST] set END_DATE_HIST = @curr_date where RECEIPT_ID in (select RECEIPT_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [permit].[ORBC_RECEIPT_HIST] ([RECEIPT_ID], [RECEIPT_NUMBER], [TRANSACTION_ID], [RECEIPT_DOCUMENT_ID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _RECEIPT_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [RECEIPT_ID], [RECEIPT_NUMBER], [TRANSACTION_ID], [RECEIPT_DOCUMENT_ID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [permit].[ORBC_RECEIPT_H_ID_SEQ]) as [_RECEIPT_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.ORBC_USER_A_S_IUD_TR
PRINT N'Create trigger dbo.ORBC_USER_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[ORBC_USER_A_S_IUD_TR] ON dbo.[ORBC_USER] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dbo].[ORBC_USER_HIST] set END_DATE_HIST = @curr_date where USER_GUID in (select USER_GUID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dbo].[ORBC_USER_HIST] ([USER_GUID], [USERNAME], [USER_DIRECTORY], [CONTACT_ID], [USER_AUTH_GROUP_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _USER_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [USER_GUID], [USERNAME], [USER_DIRECTORY], [CONTACT_ID], [USER_AUTH_GROUP_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dbo].[ORBC_USER_H_ID_SEQ]) as [_USER_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger permit.ORBC_PMTHTY_I_S_U_TR
PRINT N'Create trigger permit.ORBC_PMTHTY_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_PMTHTY_I_S_U_TR] ON permit.[ORBC_PAYMENT_METHOD_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.PAYMENT_METHOD_TYPE = deleted.PAYMENT_METHOD_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_PAYMENT_METHOD_TYPE]
    set "PAYMENT_METHOD_TYPE" = inserted."PAYMENT_METHOD_TYPE",
      "NAME" = inserted."NAME",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_PAYMENT_METHOD_TYPE]
    inner join inserted
    on (ORBC_PAYMENT_METHOD_TYPE.PAYMENT_METHOD_TYPE = inserted.PAYMENT_METHOD_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_PMTHTY_I_S_U_TR] ON permit.[ORBC_PAYMENT_METHOD_TYPE]
GO

-- Create trigger permit.ORBC_PCRDTY_I_S_U_TR
PRINT N'Create trigger permit.ORBC_PCRDTY_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_PCRDTY_I_S_U_TR] ON permit.[ORBC_PAYMENT_CARD_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.PAYMENT_CARD_TYPE = deleted.PAYMENT_CARD_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_PAYMENT_CARD_TYPE]
    set "PAYMENT_CARD_TYPE" = inserted."PAYMENT_CARD_TYPE",
      "NAME" = inserted."NAME",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_PAYMENT_CARD_TYPE]
    inner join inserted
    on (ORBC_PAYMENT_CARD_TYPE.PAYMENT_CARD_TYPE = inserted.PAYMENT_CARD_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_PCRDTY_I_S_U_TR] ON permit.[ORBC_PAYMENT_CARD_TYPE]
GO

-- Create trigger permit.ORBC_PMTTXN_I_S_U_TR
PRINT N'Create trigger permit.ORBC_PMTTXN_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_PMTTXN_I_S_U_TR] ON permit.[ORBC_PERMIT_TRANSACTION] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.ID = deleted.ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_PERMIT_TRANSACTION]
    set "PERMIT_ID" = inserted."PERMIT_ID",
      "TRANSACTION_ID" = inserted."TRANSACTION_ID",
      "TRANSACTION_AMOUNT" = inserted."TRANSACTION_AMOUNT",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_PERMIT_TRANSACTION]
    inner join inserted
    on (ORBC_PERMIT_TRANSACTION.ID = inserted.ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_PMTTXN_I_S_U_TR] ON permit.[ORBC_PERMIT_TRANSACTION]
GO

-- Create trigger permit.ORBC_PIBYTY_I_S_U_TR
PRINT N'Create trigger permit.ORBC_PIBYTY_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_PIBYTY_I_S_U_TR] ON permit.[ORBC_PERMIT_ISSUED_BY_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.PERMIT_ISSUED_BY_TYPE = deleted.PERMIT_ISSUED_BY_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_PERMIT_ISSUED_BY_TYPE]
    set "PERMIT_ISSUED_BY_TYPE" = inserted."PERMIT_ISSUED_BY_TYPE",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_PERMIT_ISSUED_BY_TYPE]
    inner join inserted
    on (ORBC_PERMIT_ISSUED_BY_TYPE.PERMIT_ISSUED_BY_TYPE = inserted.PERMIT_ISSUED_BY_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_PIBYTY_I_S_U_TR] ON permit.[ORBC_PERMIT_ISSUED_BY_TYPE]
GO

-- Create trigger dbo.ORBC_ADDR_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_ADDR_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_ADDR_I_S_U_TR] ON dbo.[ORBC_ADDRESS] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.ADDRESS_ID = deleted.ADDRESS_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_ADDRESS]
    set "ADDRESS_LINE_1" = inserted."ADDRESS_LINE_1",
      "ADDRESS_LINE_2" = inserted."ADDRESS_LINE_2",
      "CITY" = inserted."CITY",
      "PROVINCE_TYPE" = inserted."PROVINCE_TYPE",
      "POSTAL_CODE" = inserted."POSTAL_CODE",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_ADDRESS]
    inner join inserted
    on (ORBC_ADDRESS.ADDRESS_ID = inserted.ADDRESS_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_ADDR_I_S_U_TR] ON dbo.[ORBC_ADDRESS]
GO

-- Create trigger dops.ORBC_DOCMNT_A_S_IUD_TR
PRINT N'Create trigger dops.ORBC_DOCMNT_A_S_IUD_TR'
GO
CREATE TRIGGER [dops].[ORBC_DOCMNT_A_S_IUD_TR] ON dops.[ORBC_DOCUMENT] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dops].[ORBC_DOCUMENT_HIST] set END_DATE_HIST = @curr_date where ID in (select ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dops].[ORBC_DOCUMENT_HIST] ([ID], [S3_OBJECT_ID], [S3_VERSION_ID], [S3_LOCATION], [OBJECT_MIME_TYPE], [FILE_NAME], [DMS_VERSION_ID], [COMPANY_ID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _DOCUMENT_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [ID], [S3_OBJECT_ID], [S3_VERSION_ID], [S3_LOCATION], [OBJECT_MIME_TYPE], [FILE_NAME], [DMS_VERSION_ID], [COMPANY_ID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dops].[ORBC_DOCUMENT_H_ID_SEQ]) as [_DOCUMENT_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.ORBC_USER_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_USER_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_USER_I_S_U_TR] ON dbo.[ORBC_USER] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.USER_GUID = deleted.USER_GUID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_USER]
    set "USER_GUID" = inserted."USER_GUID",
      "USERNAME" = inserted."USERNAME",
      "USER_DIRECTORY" = inserted."USER_DIRECTORY",
      "CONTACT_ID" = inserted."CONTACT_ID",
      "USER_AUTH_GROUP_TYPE" = inserted."USER_AUTH_GROUP_TYPE",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_USER]
    inner join inserted
    on (ORBC_USER.USER_GUID = inserted.USER_GUID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_USER_I_S_U_TR] ON dbo.[ORBC_USER]
GO

-- Create trigger dbo.ORBC_TRLR_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_TRLR_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_TRLR_I_S_U_TR] ON dbo.[ORBC_TRAILER] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.TRAILER_ID = deleted.TRAILER_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_TRAILER]
    set "UNIT_NUMBER" = inserted."UNIT_NUMBER",
      "PLATE" = inserted."PLATE",
      "PROVINCE_TYPE" = inserted."PROVINCE_TYPE",
      "YEAR" = inserted."YEAR",
      "MAKE" = inserted."MAKE",
      "VIN" = inserted."VIN",
      "TRAILER_TYPE" = inserted."TRAILER_TYPE",
      "EMPTY_TRAILER_WIDTH" = inserted."EMPTY_TRAILER_WIDTH",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "COMPANY_ID" = inserted."COMPANY_ID"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_TRAILER]
    inner join inserted
    on (ORBC_TRAILER.TRAILER_ID = inserted.TRAILER_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_TRLR_I_S_U_TR] ON dbo.[ORBC_TRAILER]
GO

-- Create trigger dops.ORBC_DOCTMP_I_S_U_TR
PRINT N'Create trigger dops.ORBC_DOCTMP_I_S_U_TR'
GO
CREATE TRIGGER [dops].[ORBC_DOCTMP_I_S_U_TR] ON dops.[ORBC_DOCUMENT_TEMPLATE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.TEMPLATE_ID = deleted.TEMPLATE_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dops].[ORBC_DOCUMENT_TEMPLATE]
    set "TEMPLATE_NAME" = inserted."TEMPLATE_NAME",
      "TEMPLATE_VERSION" = inserted."TEMPLATE_VERSION",
      "DOCUMENT_ID" = inserted."DOCUMENT_ID",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dops].[ORBC_DOCUMENT_TEMPLATE]
    inner join inserted
    on (ORBC_DOCUMENT_TEMPLATE.TEMPLATE_ID = inserted.TEMPLATE_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dops].[ORBC_DOCTMP_I_S_U_TR] ON dops.[ORBC_DOCUMENT_TEMPLATE]
GO

-- Create trigger dbo.ORBC_CONTCT_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_CONTCT_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_CONTCT_I_S_U_TR] ON dbo.[ORBC_CONTACT] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.CONTACT_ID = deleted.CONTACT_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_CONTACT]
    set "FIRST_NAME" = inserted."FIRST_NAME",
      "LAST_NAME" = inserted."LAST_NAME",
      "EMAIL" = inserted."EMAIL",
      "PHONE_1" = inserted."PHONE_1",
      "EXTENSION_1" = inserted."EXTENSION_1",
      "PHONE_2" = inserted."PHONE_2",
      "EXTENSION_2" = inserted."EXTENSION_2",
      "FAX" = inserted."FAX",
      "CITY" = inserted."CITY",
      "PROVINCE_TYPE" = inserted."PROVINCE_TYPE",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_CONTACT]
    inner join inserted
    on (ORBC_CONTACT.CONTACT_ID = inserted.CONTACT_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_CONTCT_I_S_U_TR] ON dbo.[ORBC_CONTACT]
GO

-- Create trigger permit.ORBC_PAOTYP_I_S_U_TR
PRINT N'Create trigger permit.ORBC_PAOTYP_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_PAOTYP_I_S_U_TR] ON permit.[ORBC_PERMIT_APPLICATION_ORIGIN_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.PERMIT_APPLICATION_ORIGIN_TYPE = deleted.PERMIT_APPLICATION_ORIGIN_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_PERMIT_APPLICATION_ORIGIN_TYPE]
    set "PERMIT_APPLICATION_ORIGIN_TYPE" = inserted."PERMIT_APPLICATION_ORIGIN_TYPE",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "CODE" = inserted."CODE",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_PERMIT_APPLICATION_ORIGIN_TYPE]
    inner join inserted
    on (ORBC_PERMIT_APPLICATION_ORIGIN_TYPE.PERMIT_APPLICATION_ORIGIN_TYPE = inserted.PERMIT_APPLICATION_ORIGIN_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_PAOTYP_I_S_U_TR] ON permit.[ORBC_PERMIT_APPLICATION_ORIGIN_TYPE]
GO

-- Create trigger dbo.ORBC_COMPNY_A_S_IUD_TR
PRINT N'Create trigger dbo.ORBC_COMPNY_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[ORBC_COMPNY_A_S_IUD_TR] ON dbo.[ORBC_COMPANY] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dbo].[ORBC_COMPANY_HIST] set END_DATE_HIST = @curr_date where COMPANY_ID in (select COMPANY_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dbo].[ORBC_COMPANY_HIST] ([COMPANY_ID], [COMPANY_GUID], [CLIENT_NUMBER], [TPS_CLIENT_HASH], [LEGAL_NAME], [ALTERNATE_NAME], [COMPANY_DIRECTORY], [MAILING_ADDRESS_ID], [PHONE], [EXTENSION], [FAX], [EMAIL], [PRIMARY_CONTACT_ID], [ACCOUNT_REGION], [ACCOUNT_SOURCE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _COMPANY_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [COMPANY_ID], [COMPANY_GUID], [CLIENT_NUMBER], [TPS_CLIENT_HASH], [LEGAL_NAME], [ALTERNATE_NAME], [COMPANY_DIRECTORY], [MAILING_ADDRESS_ID], [PHONE], [EXTENSION], [FAX], [EMAIL], [PRIMARY_CONTACT_ID], [ACCOUNT_REGION], [ACCOUNT_SOURCE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dbo].[ORBC_COMPANY_H_ID_SEQ]) as [_COMPANY_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger permit.ORBC_PMTTXN_A_S_IUD_TR
PRINT N'Create trigger permit.ORBC_PMTTXN_A_S_IUD_TR'
GO
CREATE TRIGGER [permit].[ORBC_PMTTXN_A_S_IUD_TR] ON permit.[ORBC_PERMIT_TRANSACTION] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [permit].[ORBC_PERMIT_TRANSACTION_HIST] set END_DATE_HIST = @curr_date where ID in (select ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [permit].[ORBC_PERMIT_TRANSACTION_HIST] ([ID], [PERMIT_ID], [TRANSACTION_ID], [TRANSACTION_AMOUNT], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _PERMIT_TRANSACTION_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [ID], [PERMIT_ID], [TRANSACTION_ID], [TRANSACTION_AMOUNT], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [permit].[ORBC_PERMIT_TRANSACTION_H_ID_SEQ]) as [_PERMIT_TRANSACTION_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.ORBC_COMPNY_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_COMPNY_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_COMPNY_I_S_U_TR] ON dbo.[ORBC_COMPANY] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.COMPANY_ID = deleted.COMPANY_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_COMPANY]
    set "COMPANY_GUID" = inserted."COMPANY_GUID",
      "CLIENT_NUMBER" = inserted."CLIENT_NUMBER",
      "TPS_CLIENT_HASH" = inserted."TPS_CLIENT_HASH",
      "LEGAL_NAME" = inserted."LEGAL_NAME",
      "ALTERNATE_NAME" = inserted."ALTERNATE_NAME",
      "COMPANY_DIRECTORY" = inserted."COMPANY_DIRECTORY",
      "MAILING_ADDRESS_ID" = inserted."MAILING_ADDRESS_ID",
      "PHONE" = inserted."PHONE",
      "EXTENSION" = inserted."EXTENSION",
      "FAX" = inserted."FAX",
      "EMAIL" = inserted."EMAIL",
      "PRIMARY_CONTACT_ID" = inserted."PRIMARY_CONTACT_ID",
      "ACCOUNT_REGION" = inserted."ACCOUNT_REGION",
      "ACCOUNT_SOURCE" = inserted."ACCOUNT_SOURCE",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_COMPANY]
    inner join inserted
    on (ORBC_COMPANY.COMPANY_ID = inserted.COMPANY_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_COMPNY_I_S_U_TR] ON dbo.[ORBC_COMPANY]
GO

-- Create trigger permit.ORBC_PMTDAT_I_S_U_TR
PRINT N'Create trigger permit.ORBC_PMTDAT_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_PMTDAT_I_S_U_TR] ON permit.[ORBC_PERMIT_DATA] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.ID = deleted.ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_PERMIT_DATA]
    set "PERMIT_ID" = inserted."PERMIT_ID",
      "PERMIT_DATA" = inserted."PERMIT_DATA",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_PERMIT_DATA]
    inner join inserted
    on (ORBC_PERMIT_DATA.ID = inserted.ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_PMTDAT_I_S_U_TR] ON permit.[ORBC_PERMIT_DATA]
GO

-- Create trigger dbo.ORBC_TRLR_A_S_IUD_TR
PRINT N'Create trigger dbo.ORBC_TRLR_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[ORBC_TRLR_A_S_IUD_TR] ON dbo.[ORBC_TRAILER] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dbo].[ORBC_TRAILER_HIST] set END_DATE_HIST = @curr_date where TRAILER_ID in (select TRAILER_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dbo].[ORBC_TRAILER_HIST] ([TRAILER_ID], [UNIT_NUMBER], [PLATE], [PROVINCE_TYPE], [YEAR], [MAKE], [VIN], [TRAILER_TYPE], [EMPTY_TRAILER_WIDTH], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [COMPANY_ID], _TRAILER_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [TRAILER_ID], [UNIT_NUMBER], [PLATE], [PROVINCE_TYPE], [YEAR], [MAKE], [VIN], [TRAILER_TYPE], [EMPTY_TRAILER_WIDTH], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [COMPANY_ID], (next value for [dbo].[ORBC_TRAILER_H_ID_SEQ]) as [_TRAILER_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.ORBC_DIRTYP_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_DIRTYP_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_DIRTYP_I_S_U_TR] ON dbo.[ORBC_DIRECTORY_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.DIRECTORY_TYPE = deleted.DIRECTORY_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_DIRECTORY_TYPE]
    set "DIRECTORY_TYPE" = inserted."DIRECTORY_TYPE",
      "DIRECTORY_NAME" = inserted."DIRECTORY_NAME",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_DIRECTORY_TYPE]
    inner join inserted
    on (ORBC_DIRECTORY_TYPE.DIRECTORY_TYPE = inserted.DIRECTORY_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_DIRTYP_I_S_U_TR] ON dbo.[ORBC_DIRECTORY_TYPE]
GO

-- Create trigger dbo.ORBC_IDRUSR_A_S_IUD_TR
PRINT N'Create trigger dbo.ORBC_IDRUSR_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[ORBC_IDRUSR_A_S_IUD_TR] ON dbo.[ORBC_IDIR_USER] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dbo].[ORBC_IDIR_USER_HIST] set END_DATE_HIST = @curr_date where USER_GUID in (select USER_GUID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dbo].[ORBC_IDIR_USER_HIST] ([USER_GUID], [USERNAME], [FIRST_NAME], [LAST_NAME], [EMAIL], [USER_STATUS_TYPE], [USER_AUTH_GROUP_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _IDIR_USER_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [USER_GUID], [USERNAME], [FIRST_NAME], [LAST_NAME], [EMAIL], [USER_STATUS_TYPE], [USER_AUTH_GROUP_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dbo].[ORBC_IDIR_USER_H_ID_SEQ]) as [_IDIR_USER_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.ORBC_PWRUNI_A_S_IUD_TR
PRINT N'Create trigger dbo.ORBC_PWRUNI_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[ORBC_PWRUNI_A_S_IUD_TR] ON dbo.[ORBC_POWER_UNIT] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dbo].[ORBC_POWER_UNIT_HIST] set END_DATE_HIST = @curr_date where POWER_UNIT_ID in (select POWER_UNIT_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dbo].[ORBC_POWER_UNIT_HIST] ([POWER_UNIT_ID], [UNIT_NUMBER], [PLATE], [PROVINCE_TYPE], [YEAR], [MAKE], [VIN], [LICENSED_GVW], [POWER_UNIT_TYPE], [STEER_AXLE_TIRE_SIZE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [COMPANY_ID], _POWER_UNIT_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [POWER_UNIT_ID], [UNIT_NUMBER], [PLATE], [PROVINCE_TYPE], [YEAR], [MAKE], [VIN], [LICENSED_GVW], [POWER_UNIT_TYPE], [STEER_AXLE_TIRE_SIZE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], [COMPANY_ID], (next value for [dbo].[ORBC_POWER_UNIT_H_ID_SEQ]) as [_POWER_UNIT_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.ORBC_CMPUSR_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_CMPUSR_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_CMPUSR_I_S_U_TR] ON dbo.[ORBC_COMPANY_USER] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.COMPANY_USER_ID = deleted.COMPANY_USER_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_COMPANY_USER]
    set "COMPANY_ID" = inserted."COMPANY_ID",
      "USER_GUID" = inserted."USER_GUID",
      "USER_AUTH_GROUP_TYPE" = inserted."USER_AUTH_GROUP_TYPE",
      "USER_STATUS_TYPE" = inserted."USER_STATUS_TYPE",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_COMPANY_USER]
    inner join inserted
    on (ORBC_COMPANY_USER.COMPANY_USER_ID = inserted.COMPANY_USER_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_CMPUSR_I_S_U_TR] ON dbo.[ORBC_COMPANY_USER]
GO

-- Create trigger dops.ORBC_EXTDOC_A_S_IUD_TR
PRINT N'Create trigger dops.ORBC_EXTDOC_A_S_IUD_TR'
GO
CREATE TRIGGER [dops].[ORBC_EXTDOC_A_S_IUD_TR] ON dops.[ORBC_EXTERNAL_DOCUMENT] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dops].[ORBC_EXTERNAL_DOCUMENT_HIST] set END_DATE_HIST = @curr_date where ID in (select ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dops].[ORBC_EXTERNAL_DOCUMENT_HIST] ([ID], [DOCUMENT_NAME], [DOCUMENT_DESCRIPTION], [DOCUMENT_LOCATION], [DOCUMENT_MIME_TYPE], [DOCUMENT_VERSION_ID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _EXTERNAL_DOCUMENT_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [ID], [DOCUMENT_NAME], [DOCUMENT_DESCRIPTION], [DOCUMENT_LOCATION], [DOCUMENT_MIME_TYPE], [DOCUMENT_VERSION_ID], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dops].[ORBC_EXTERNAL_DOCUMENT_H_ID_SEQ]) as [_EXTERNAL_DOCUMENT_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.ORBC_CMPUSR_A_S_IUD_TR
PRINT N'Create trigger dbo.ORBC_CMPUSR_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[ORBC_CMPUSR_A_S_IUD_TR] ON dbo.[ORBC_COMPANY_USER] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dbo].[ORBC_COMPANY_USER_HIST] set END_DATE_HIST = @curr_date where COMPANY_USER_ID in (select COMPANY_USER_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dbo].[ORBC_COMPANY_USER_HIST] ([COMPANY_USER_ID], [COMPANY_ID], [USER_GUID], [USER_AUTH_GROUP_TYPE], [USER_STATUS_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _COMPANY_USER_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [COMPANY_USER_ID], [COMPANY_ID], [USER_GUID], [USER_AUTH_GROUP_TYPE], [USER_STATUS_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dbo].[ORBC_COMPANY_USER_H_ID_SEQ]) as [_COMPANY_USER_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger access.ORBC_ROLTYP_I_S_U_TR
PRINT N'Create trigger access.ORBC_ROLTYP_I_S_U_TR'
GO
CREATE TRIGGER [access].[ORBC_ROLTYP_I_S_U_TR] ON access.[ORBC_ROLE_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.ROLE_TYPE = deleted.ROLE_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [access].[ORBC_ROLE_TYPE]
    set "ROLE_TYPE" = inserted."ROLE_TYPE",
      "ROLE_DESCRIPTION" = inserted."ROLE_DESCRIPTION",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [access].[ORBC_ROLE_TYPE]
    inner join inserted
    on (ORBC_ROLE_TYPE.ROLE_TYPE = inserted.ROLE_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [access].[ORBC_ROLTYP_I_S_U_TR] ON access.[ORBC_ROLE_TYPE]
GO

-- Create trigger access.ORBC_UAGRPT_I_S_U_TR
PRINT N'Create trigger access.ORBC_UAGRPT_I_S_U_TR'
GO
CREATE TRIGGER [access].[ORBC_UAGRPT_I_S_U_TR] ON access.[ORBC_USER_AUTH_GROUP_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.USER_AUTH_GROUP_TYPE = deleted.USER_AUTH_GROUP_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [access].[ORBC_USER_AUTH_GROUP_TYPE]
    set "USER_AUTH_GROUP_TYPE" = inserted."USER_AUTH_GROUP_TYPE",
      "DISPLAY_NAME" = inserted."DISPLAY_NAME",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "STAFF_FLAG" = inserted."STAFF_FLAG",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [access].[ORBC_USER_AUTH_GROUP_TYPE]
    inner join inserted
    on (ORBC_USER_AUTH_GROUP_TYPE.USER_AUTH_GROUP_TYPE = inserted.USER_AUTH_GROUP_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [access].[ORBC_UAGRPT_I_S_U_TR] ON access.[ORBC_USER_AUTH_GROUP_TYPE]
GO

-- Create trigger dbo.ORBC_USTSTY_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_USTSTY_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_USTSTY_I_S_U_TR] ON dbo.[ORBC_USER_STATUS_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.USER_STATUS_TYPE = deleted.USER_STATUS_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_USER_STATUS_TYPE]
    set "USER_STATUS_TYPE" = inserted."USER_STATUS_TYPE",
      "DISPLAY_NAME" = inserted."DISPLAY_NAME",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_USER_STATUS_TYPE]
    inner join inserted
    on (ORBC_USER_STATUS_TYPE.USER_STATUS_TYPE = inserted.USER_STATUS_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_USTSTY_I_S_U_TR] ON dbo.[ORBC_USER_STATUS_TYPE]
GO

-- Create trigger permit.ORBC_PMTCMT_A_S_IUD_TR
PRINT N'Create trigger permit.ORBC_PMTCMT_A_S_IUD_TR'
GO
CREATE TRIGGER [permit].[ORBC_PMTCMT_A_S_IUD_TR] ON permit.[ORBC_PERMIT_COMMENTS] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [permit].[ORBC_PERMIT_COMMENTS_HIST] set END_DATE_HIST = @curr_date where ID in (select ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [permit].[ORBC_PERMIT_COMMENTS_HIST] ([ID], [PERMIT_ID], [COMMENT], [INTERNAL_ONLY], [USER_GUID], [COMMENT_DATE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _PERMIT_COMMENTS_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [ID], [PERMIT_ID], [COMMENT], [INTERNAL_ONLY], [USER_GUID], [COMMENT_DATE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [permit].[ORBC_PERMIT_COMMENTS_H_ID_SEQ]) as [_PERMIT_COMMENTS_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger permit.ORBC_TXNTYP_I_S_U_TR
PRINT N'Create trigger permit.ORBC_TXNTYP_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_TXNTYP_I_S_U_TR] ON permit.[ORBC_TRANSACTION_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.TRANSACTION_TYPE = deleted.TRANSACTION_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_TRANSACTION_TYPE]
    set "TRANSACTION_TYPE" = inserted."TRANSACTION_TYPE",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_TRANSACTION_TYPE]
    inner join inserted
    on (ORBC_TRANSACTION_TYPE.TRANSACTION_TYPE = inserted.TRANSACTION_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_TXNTYP_I_S_U_TR] ON permit.[ORBC_TRANSACTION_TYPE]
GO

-- Create trigger dbo.ORBC_PWRUNI_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_PWRUNI_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_PWRUNI_I_S_U_TR] ON dbo.[ORBC_POWER_UNIT] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.POWER_UNIT_ID = deleted.POWER_UNIT_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_POWER_UNIT]
    set "UNIT_NUMBER" = inserted."UNIT_NUMBER",
      "PLATE" = inserted."PLATE",
      "PROVINCE_TYPE" = inserted."PROVINCE_TYPE",
      "YEAR" = inserted."YEAR",
      "MAKE" = inserted."MAKE",
      "VIN" = inserted."VIN",
      "LICENSED_GVW" = inserted."LICENSED_GVW",
      "POWER_UNIT_TYPE" = inserted."POWER_UNIT_TYPE",
      "STEER_AXLE_TIRE_SIZE" = inserted."STEER_AXLE_TIRE_SIZE",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER",
      "COMPANY_ID" = inserted."COMPANY_ID"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_POWER_UNIT]
    inner join inserted
    on (ORBC_POWER_UNIT.POWER_UNIT_ID = inserted.POWER_UNIT_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_PWRUNI_I_S_U_TR] ON dbo.[ORBC_POWER_UNIT]
GO

-- Create trigger dops.ORBC_EXTDOC_I_S_U_TR
PRINT N'Create trigger dops.ORBC_EXTDOC_I_S_U_TR'
GO
CREATE TRIGGER [dops].[ORBC_EXTDOC_I_S_U_TR] ON dops.[ORBC_EXTERNAL_DOCUMENT] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.ID = deleted.ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dops].[ORBC_EXTERNAL_DOCUMENT]
    set "DOCUMENT_NAME" = inserted."DOCUMENT_NAME",
      "DOCUMENT_DESCRIPTION" = inserted."DOCUMENT_DESCRIPTION",
      "DOCUMENT_LOCATION" = inserted."DOCUMENT_LOCATION",
      "DOCUMENT_MIME_TYPE" = inserted."DOCUMENT_MIME_TYPE",
      "DOCUMENT_VERSION_ID" = inserted."DOCUMENT_VERSION_ID",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dops].[ORBC_EXTERNAL_DOCUMENT]
    inner join inserted
    on (ORBC_EXTERNAL_DOCUMENT.ID = inserted.ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dops].[ORBC_EXTDOC_I_S_U_TR] ON dops.[ORBC_EXTERNAL_DOCUMENT]
GO

-- Create trigger dbo.ORBC_TRLRTY_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_TRLRTY_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_TRLRTY_I_S_U_TR] ON dbo.[ORBC_TRAILER_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.TRAILER_TYPE = deleted.TRAILER_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_TRAILER_TYPE]
    set "TRAILER_TYPE" = inserted."TRAILER_TYPE",
      "TYPE" = inserted."TYPE",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "SORT_ORDER" = inserted."SORT_ORDER",
      "IS_ACTIVE" = inserted."IS_ACTIVE",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_TRAILER_TYPE]
    inner join inserted
    on (ORBC_TRAILER_TYPE.TRAILER_TYPE = inserted.TRAILER_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_TRLRTY_I_S_U_TR] ON dbo.[ORBC_TRAILER_TYPE]
GO

-- Create trigger dbo.ORBC_PIDRUS_A_S_IUD_TR
PRINT N'Create trigger dbo.ORBC_PIDRUS_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[ORBC_PIDRUS_A_S_IUD_TR] ON dbo.[ORBC_PENDING_IDIR_USER] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dbo].[ORBC_PENDING_IDIR_USER_HIST] set END_DATE_HIST = @curr_date where USERNAME in (select USERNAME from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dbo].[ORBC_PENDING_IDIR_USER_HIST] ([USERNAME], [USER_AUTH_GROUP_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _PENDING_IDIR_USER_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [USERNAME], [USER_AUTH_GROUP_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dbo].[ORBC_PENDING_IDIR_USER_H_ID_SEQ]) as [_PENDING_IDIR_USER_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.ORBC_CNTTYP_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_CNTTYP_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_CNTTYP_I_S_U_TR] ON dbo.[ORBC_COUNTRY_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.COUNTRY_TYPE = deleted.COUNTRY_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_COUNTRY_TYPE]
    set "COUNTRY_TYPE" = inserted."COUNTRY_TYPE",
      "COUNTRY_NAME" = inserted."COUNTRY_NAME",
      "SORT_ORDER" = inserted."SORT_ORDER",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_COUNTRY_TYPE]
    inner join inserted
    on (ORBC_COUNTRY_TYPE.COUNTRY_TYPE = inserted.COUNTRY_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_CNTTYP_I_S_U_TR] ON dbo.[ORBC_COUNTRY_TYPE]
GO

-- Create trigger permit.ORBC_RCPT_I_S_U_TR
PRINT N'Create trigger permit.ORBC_RCPT_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_RCPT_I_S_U_TR] ON permit.[ORBC_RECEIPT] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.RECEIPT_ID = deleted.RECEIPT_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_RECEIPT]
    set "RECEIPT_NUMBER" = inserted."RECEIPT_NUMBER",
      "TRANSACTION_ID" = inserted."TRANSACTION_ID",
      "RECEIPT_DOCUMENT_ID" = inserted."RECEIPT_DOCUMENT_ID",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_RECEIPT]
    inner join inserted
    on (ORBC_RECEIPT.RECEIPT_ID = inserted.RECEIPT_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_RCPT_I_S_U_TR] ON permit.[ORBC_RECEIPT]
GO

-- Create trigger permit.ORBC_TXN_A_S_IUD_TR
PRINT N'Create trigger permit.ORBC_TXN_A_S_IUD_TR'
GO
CREATE TRIGGER [permit].[ORBC_TXN_A_S_IUD_TR] ON permit.[ORBC_TRANSACTION] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [permit].[ORBC_TRANSACTION_HIST] set END_DATE_HIST = @curr_date where TRANSACTION_ID in (select TRANSACTION_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [permit].[ORBC_TRANSACTION_HIST] ([TRANSACTION_ID], [TRANSACTION_TYPE], [PAYMENT_METHOD_TYPE], [PAYMENT_CARD_TYPE], [TOTAL_TRANSACTION_AMOUNT], [TRANSACTION_SUBMIT_DATE], [TRANSACTION_ORDER_NUMBER], [PG_TRANSACTION_ID], [PG_TRANSACTION_APPROVED], [PG_AUTH_CODE], [PG_TRANSACTION_CARD_TYPE], [PG_TRANSACTION_DATE], [PG_CVD_ID], [PG_PAYMENT_METHOD], [PG_MESSAGE_ID], [PG_MESSAGE_TEXT], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _TRANSACTION_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [TRANSACTION_ID], [TRANSACTION_TYPE], [PAYMENT_METHOD_TYPE], [PAYMENT_CARD_TYPE], [TOTAL_TRANSACTION_AMOUNT], [TRANSACTION_SUBMIT_DATE], [TRANSACTION_ORDER_NUMBER], [PG_TRANSACTION_ID], [PG_TRANSACTION_APPROVED], [PG_AUTH_CODE], [PG_TRANSACTION_CARD_TYPE], [PG_TRANSACTION_DATE], [PG_CVD_ID], [PG_PAYMENT_METHOD], [PG_MESSAGE_ID], [PG_MESSAGE_TEXT], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [permit].[ORBC_TRANSACTION_H_ID_SEQ]) as [_TRANSACTION_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger permit.ORBC_PERMIT_I_S_U_TR
PRINT N'Create trigger permit.ORBC_PERMIT_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_PERMIT_I_S_U_TR] ON permit.[ORBC_PERMIT] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.ID = deleted.ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_PERMIT]
    set "ORIGINAL_ID" = inserted."ORIGINAL_ID",
      "COMPANY_ID" = inserted."COMPANY_ID",
      "PERMIT_TYPE" = inserted."PERMIT_TYPE",
      "PERMIT_APPROVAL_SOURCE_TYPE" = inserted."PERMIT_APPROVAL_SOURCE_TYPE",
      "PERMIT_ISSUED_BY_TYPE" = inserted."PERMIT_ISSUED_BY_TYPE",
      "ISSUER_USER_GUID" = inserted."ISSUER_USER_GUID",
      "PERMIT_APPLICATION_ORIGIN_TYPE" = inserted."PERMIT_APPLICATION_ORIGIN_TYPE",
      "APPLICATION_NUMBER" = inserted."APPLICATION_NUMBER",
      "PERMIT_NUMBER" = inserted."PERMIT_NUMBER",
      "TPS_PERMIT_NUMBER" = inserted."TPS_PERMIT_NUMBER",
      "REVISION" = inserted."REVISION",
      "PREVIOUS_REV_ID" = inserted."PREVIOUS_REV_ID",
      "OWNER_USER_GUID" = inserted."OWNER_USER_GUID",
      "PERMIT_STATUS_TYPE" = inserted."PERMIT_STATUS_TYPE",
      "PERMIT_ISSUE_DATE_TIME" = inserted."PERMIT_ISSUE_DATE_TIME",
      "DOCUMENT_ID" = inserted."DOCUMENT_ID",
      "COMMENT" = inserted."COMMENT",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_PERMIT]
    inner join inserted
    on (ORBC_PERMIT.ID = inserted.ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_PERMIT_I_S_U_TR] ON permit.[ORBC_PERMIT]
GO

-- Create trigger dbo.ORBC_CONTCT_A_S_IUD_TR
PRINT N'Create trigger dbo.ORBC_CONTCT_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[ORBC_CONTCT_A_S_IUD_TR] ON dbo.[ORBC_CONTACT] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dbo].[ORBC_CONTACT_HIST] set END_DATE_HIST = @curr_date where CONTACT_ID in (select CONTACT_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dbo].[ORBC_CONTACT_HIST] ([CONTACT_ID], [FIRST_NAME], [LAST_NAME], [EMAIL], [PHONE_1], [EXTENSION_1], [PHONE_2], [EXTENSION_2], [FAX], [CITY], [PROVINCE_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _CONTACT_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [CONTACT_ID], [FIRST_NAME], [LAST_NAME], [EMAIL], [PHONE_1], [EXTENSION_1], [PHONE_2], [EXTENSION_2], [FAX], [CITY], [PROVINCE_TYPE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dbo].[ORBC_CONTACT_H_ID_SEQ]) as [_CONTACT_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger permit.ORBC_PMAPST_I_S_U_TR
PRINT N'Create trigger permit.ORBC_PMAPST_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_PMAPST_I_S_U_TR] ON permit.[ORBC_PERMIT_APPROVAL_SOURCE_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.PERMIT_APPROVAL_SOURCE_TYPE = deleted.PERMIT_APPROVAL_SOURCE_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_PERMIT_APPROVAL_SOURCE_TYPE]
    set "PERMIT_APPROVAL_SOURCE_TYPE" = inserted."PERMIT_APPROVAL_SOURCE_TYPE",
      "DESCRIPTION" = inserted."DESCRIPTION",
      "CODE" = inserted."CODE",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_PERMIT_APPROVAL_SOURCE_TYPE]
    inner join inserted
    on (ORBC_PERMIT_APPROVAL_SOURCE_TYPE.PERMIT_APPROVAL_SOURCE_TYPE = inserted.PERMIT_APPROVAL_SOURCE_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_PMAPST_I_S_U_TR] ON permit.[ORBC_PERMIT_APPROVAL_SOURCE_TYPE]
GO

-- Create trigger permit.ORBC_PERMIT_A_S_IUD_TR
PRINT N'Create trigger permit.ORBC_PERMIT_A_S_IUD_TR'
GO
CREATE TRIGGER [permit].[ORBC_PERMIT_A_S_IUD_TR] ON permit.[ORBC_PERMIT] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [permit].[ORBC_PERMIT_HIST] set END_DATE_HIST = @curr_date where ID in (select ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [permit].[ORBC_PERMIT_HIST] ([ID], [ORIGINAL_ID], [COMPANY_ID], [PERMIT_TYPE], [PERMIT_APPROVAL_SOURCE_TYPE], [PERMIT_ISSUED_BY_TYPE], [ISSUER_USER_GUID], [PERMIT_APPLICATION_ORIGIN_TYPE], [APPLICATION_NUMBER], [PERMIT_NUMBER], [TPS_PERMIT_NUMBER], [REVISION], [PREVIOUS_REV_ID], [OWNER_USER_GUID], [PERMIT_STATUS_TYPE], [PERMIT_ISSUE_DATE_TIME], [DOCUMENT_ID], [COMMENT], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _PERMIT_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [ID], [ORIGINAL_ID], [COMPANY_ID], [PERMIT_TYPE], [PERMIT_APPROVAL_SOURCE_TYPE], [PERMIT_ISSUED_BY_TYPE], [ISSUER_USER_GUID], [PERMIT_APPLICATION_ORIGIN_TYPE], [APPLICATION_NUMBER], [PERMIT_NUMBER], [TPS_PERMIT_NUMBER], [REVISION], [PREVIOUS_REV_ID], [OWNER_USER_GUID], [PERMIT_STATUS_TYPE], [PERMIT_ISSUE_DATE_TIME], [DOCUMENT_ID], [COMMENT], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [permit].[ORBC_PERMIT_H_ID_SEQ]) as [_PERMIT_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger dbo.ORBC_IDRUSR_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_IDRUSR_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_IDRUSR_I_S_U_TR] ON dbo.[ORBC_IDIR_USER] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.USER_GUID = deleted.USER_GUID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_IDIR_USER]
    set "USER_GUID" = inserted."USER_GUID",
      "USERNAME" = inserted."USERNAME",
      "FIRST_NAME" = inserted."FIRST_NAME",
      "LAST_NAME" = inserted."LAST_NAME",
      "EMAIL" = inserted."EMAIL",
      "USER_STATUS_TYPE" = inserted."USER_STATUS_TYPE",
      "USER_AUTH_GROUP_TYPE" = inserted."USER_AUTH_GROUP_TYPE",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_IDIR_USER]
    inner join inserted
    on (ORBC_IDIR_USER.USER_GUID = inserted.USER_GUID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_IDRUSR_I_S_U_TR] ON dbo.[ORBC_IDIR_USER]
GO

-- Create trigger dbo.ORBC_PIDRUS_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_PIDRUS_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_PIDRUS_I_S_U_TR] ON dbo.[ORBC_PENDING_IDIR_USER] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.USERNAME = deleted.USERNAME)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_PENDING_IDIR_USER]
    set "USERNAME" = inserted."USERNAME",
      "USER_AUTH_GROUP_TYPE" = inserted."USER_AUTH_GROUP_TYPE",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_PENDING_IDIR_USER]
    inner join inserted
    on (ORBC_PENDING_IDIR_USER.USERNAME = inserted.USERNAME);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_PIDRUS_I_S_U_TR] ON dbo.[ORBC_PENDING_IDIR_USER]
GO

-- Create trigger permit.ORBC_PMTCMT_I_S_U_TR
PRINT N'Create trigger permit.ORBC_PMTCMT_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_PMTCMT_I_S_U_TR] ON permit.[ORBC_PERMIT_COMMENTS] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.ID = deleted.ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_PERMIT_COMMENTS]
    set "PERMIT_ID" = inserted."PERMIT_ID",
      "COMMENT" = inserted."COMMENT",
      "INTERNAL_ONLY" = inserted."INTERNAL_ONLY",
      "USER_GUID" = inserted."USER_GUID",
      "COMMENT_DATE" = inserted."COMMENT_DATE",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_PERMIT_COMMENTS]
    inner join inserted
    on (ORBC_PERMIT_COMMENTS.ID = inserted.ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_PMTCMT_I_S_U_TR] ON permit.[ORBC_PERMIT_COMMENTS]
GO

-- Create trigger access.ORBC_GRPROL_I_S_U_TR
PRINT N'Create trigger access.ORBC_GRPROL_I_S_U_TR'
GO
CREATE TRIGGER [access].[ORBC_GRPROL_I_S_U_TR] ON access.[ORBC_GROUP_ROLE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.GROUP_ROLE_ID = deleted.GROUP_ROLE_ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [access].[ORBC_GROUP_ROLE]
    set "USER_AUTH_GROUP_TYPE" = inserted."USER_AUTH_GROUP_TYPE",
      "ROLE_TYPE" = inserted."ROLE_TYPE",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [access].[ORBC_GROUP_ROLE]
    inner join inserted
    on (ORBC_GROUP_ROLE.GROUP_ROLE_ID = inserted.GROUP_ROLE_ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [access].[ORBC_GRPROL_I_S_U_TR] ON access.[ORBC_GROUP_ROLE]
GO

-- Create trigger permit.ORBC_PMTTYP_I_S_U_TR
PRINT N'Create trigger permit.ORBC_PMTTYP_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_PMTTYP_I_S_U_TR] ON permit.[ORBC_PERMIT_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.PERMIT_TYPE = deleted.PERMIT_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_PERMIT_TYPE]
    set "PERMIT_TYPE" = inserted."PERMIT_TYPE",
      "NAME" = inserted."NAME",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_PERMIT_TYPE]
    inner join inserted
    on (ORBC_PERMIT_TYPE.PERMIT_TYPE = inserted.PERMIT_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_PMTTYP_I_S_U_TR] ON permit.[ORBC_PERMIT_TYPE]
GO

-- Create trigger dbo.ORBC_PNDUSR_A_S_IUD_TR
PRINT N'Create trigger dbo.ORBC_PNDUSR_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[ORBC_PNDUSR_A_S_IUD_TR] ON dbo.[ORBC_PENDING_USER] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dbo].[ORBC_PENDING_USER_HIST] set END_DATE_HIST = @curr_date where PENDING_USER_ID in (select PENDING_USER_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dbo].[ORBC_PENDING_USER_HIST] ([PENDING_USER_ID], [COMPANY_ID], [USERNAME], [USER_GUID], [USER_AUTH_GROUP_TYPE], [FIRST_NAME], [LAST_NAME], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _PENDING_USER_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [PENDING_USER_ID], [COMPANY_ID], [USERNAME], [USER_GUID], [USER_AUTH_GROUP_TYPE], [FIRST_NAME], [LAST_NAME], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dbo].[ORBC_PENDING_USER_H_ID_SEQ]) as [_PENDING_USER_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger permit.ORBC_PMTST_I_S_U_TR
PRINT N'Create trigger permit.ORBC_PMTST_I_S_U_TR'
GO
CREATE TRIGGER [permit].[ORBC_PMTST_I_S_U_TR] ON permit.[ORBC_PERMIT_STATE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.ID = deleted.ID)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [permit].[ORBC_PERMIT_STATE]
    set "PERMIT_ID" = inserted."PERMIT_ID",
      "PERMIT_STATUS_TYPE" = inserted."PERMIT_STATUS_TYPE",
      "STATE_CHANGE_DATE" = inserted."STATE_CHANGE_DATE",
      "USER_GUID" = inserted."USER_GUID",
      "APP_LAST_UPDATE_TIMESTAMP" = inserted."APP_LAST_UPDATE_TIMESTAMP",
      "APP_LAST_UPDATE_USERID" = inserted."APP_LAST_UPDATE_USERID",
      "APP_LAST_UPDATE_USER_GUID" = inserted."APP_LAST_UPDATE_USER_GUID",
      "APP_LAST_UPDATE_USER_DIRECTORY" = inserted."APP_LAST_UPDATE_USER_DIRECTORY",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [permit].[ORBC_PERMIT_STATE]
    inner join inserted
    on (ORBC_PERMIT_STATE.ID = inserted.ID);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [permit].[ORBC_PMTST_I_S_U_TR] ON permit.[ORBC_PERMIT_STATE]
GO

-- Create trigger dbo.ORBC_PRVTYP_I_S_U_TR
PRINT N'Create trigger dbo.ORBC_PRVTYP_I_S_U_TR'
GO
CREATE TRIGGER [dbo].[ORBC_PRVTYP_I_S_U_TR] ON dbo.[ORBC_PROVINCE_TYPE] INSTEAD OF UPDATE AS
SET NOCOUNT ON
BEGIN TRY
  IF NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- validate concurrency control
  if exists (select 1 from inserted, deleted where inserted.CONCURRENCY_CONTROL_NUMBER != deleted.CONCURRENCY_CONTROL_NUMBER+1 AND inserted.PROVINCE_TYPE = deleted.PROVINCE_TYPE)
    raiserror('CONCURRENCY FAILURE.',16,1)


  -- update statement
  update [dbo].[ORBC_PROVINCE_TYPE]
    set "PROVINCE_TYPE" = inserted."PROVINCE_TYPE",
      "PROVINCE_CODE" = inserted."PROVINCE_CODE",
      "PROVINCE_NAME" = inserted."PROVINCE_NAME",
      "COUNTRY_TYPE" = inserted."COUNTRY_TYPE",
      "SORT_ORDER" = inserted."SORT_ORDER",
      "CONCURRENCY_CONTROL_NUMBER" = inserted."CONCURRENCY_CONTROL_NUMBER"
    , DB_LAST_UPDATE_TIMESTAMP = getutcdate()
    , DB_LAST_UPDATE_USERID = user_name()
    from [dbo].[ORBC_PROVINCE_TYPE]
    inner join inserted
    on (ORBC_PROVINCE_TYPE.PROVINCE_TYPE = inserted.PROVINCE_TYPE);

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DISABLE TRIGGER [dbo].[ORBC_PRVTYP_I_S_U_TR] ON dbo.[ORBC_PROVINCE_TYPE]
GO

-- Create trigger dbo.ORBC_ADDR_A_S_IUD_TR
PRINT N'Create trigger dbo.ORBC_ADDR_A_S_IUD_TR'
GO
CREATE TRIGGER [dbo].[ORBC_ADDR_A_S_IUD_TR] ON dbo.[ORBC_ADDRESS] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [dbo].[ORBC_ADDRESS_HIST] set END_DATE_HIST = @curr_date where ADDRESS_ID in (select ADDRESS_ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [dbo].[ORBC_ADDRESS_HIST] ([ADDRESS_ID], [ADDRESS_LINE_1], [ADDRESS_LINE_2], [CITY], [PROVINCE_TYPE], [POSTAL_CODE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _ADDRESS_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [ADDRESS_ID], [ADDRESS_LINE_1], [ADDRESS_LINE_2], [CITY], [PROVINCE_TYPE], [POSTAL_CODE], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [dbo].[ORBC_ADDRESS_H_ID_SEQ]) as [_ADDRESS_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

-- Create trigger permit.ORBC_PMTDAT_A_S_IUD_TR
PRINT N'Create trigger permit.ORBC_PMTDAT_A_S_IUD_TR'
GO
CREATE TRIGGER [permit].[ORBC_PMTDAT_A_S_IUD_TR] ON permit.[ORBC_PERMIT_DATA] FOR INSERT, UPDATE, DELETE AS
SET NOCOUNT ON
BEGIN TRY
DECLARE @curr_date datetime;
SET @curr_date = getutcdate();
  IF NOT EXISTS(SELECT * FROM inserted) AND NOT EXISTS(SELECT * FROM deleted) 
    RETURN;

  -- historical
  IF EXISTS(SELECT * FROM deleted)
    update [permit].[ORBC_PERMIT_DATA_HIST] set END_DATE_HIST = @curr_date where ID in (select ID from deleted) and END_DATE_HIST is null;
  
  IF EXISTS(SELECT * FROM inserted)
    insert into [permit].[ORBC_PERMIT_DATA_HIST] ([ID], [PERMIT_ID], [PERMIT_DATA], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], _PERMIT_DATA_HIST_ID, END_DATE_HIST, EFFECTIVE_DATE_HIST)
      select [ID], [PERMIT_ID], [PERMIT_DATA], [APP_CREATE_TIMESTAMP], [APP_CREATE_USERID], [APP_CREATE_USER_GUID], [APP_CREATE_USER_DIRECTORY], [APP_LAST_UPDATE_TIMESTAMP], [APP_LAST_UPDATE_USERID], [APP_LAST_UPDATE_USER_GUID], [APP_LAST_UPDATE_USER_DIRECTORY], [CONCURRENCY_CONTROL_NUMBER], [DB_CREATE_USERID], [DB_CREATE_TIMESTAMP], [DB_LAST_UPDATE_USERID], [DB_LAST_UPDATE_TIMESTAMP], (next value for [permit].[ORBC_PERMIT_DATA_H_ID_SEQ]) as [_PERMIT_DATA_HIST_ID], null as [END_DATE_HIST], @curr_date as [EFFECTIVE_DATE_HIST] from inserted;

END TRY
BEGIN CATCH
   IF @@trancount > 0 ROLLBACK TRANSACTION
   EXEC orbc_error_handling
END CATCH;
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO

COMMIT TRANSACTION
GO
IF @@ERROR <> 0 SET NOEXEC ON
GO
DECLARE @Success AS BIT
SET @Success = 1
SET NOEXEC OFF
IF (@Success = 1) PRINT 'The database update succeeded'
ELSE BEGIN
   IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION
   PRINT 'The database update failed'
END
GO

DECLARE @VersionDescription VARCHAR(255)
SET @VersionDescription = 'Add audit and history tables, with triggers'

INSERT [dbo].[ORBC_SYS_VERSION] ([VERSION_ID], [DESCRIPTION], [UPDATE_SCRIPT], [REVERT_SCRIPT], [RELEASE_DATE]) VALUES (11, @VersionDescription, '$(UPDATE_SCRIPT)', '$(REVERT_SCRIPT)', getutcdate())
